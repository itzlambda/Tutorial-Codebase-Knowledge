<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorial Codebase Knowledge</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tutorial Codebase Knowledge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tutorial-revm"><a class="header" href="#tutorial-revm">Tutorial: revm</a></h1>
<p>This project implements a full Ethereum Virtual Machine (EVM) environment with <strong>modular abstractions</strong> for executing and managing <em>smart contract</em> code.<br />
It includes an <strong>Interpreter</strong> that processes EVM bytecode step-by-step, a <strong>Host Interface</strong> that connects the EVM to blockchain state and external data,<br />
and <strong>Precompiles</strong>, which are highly optimized native contracts for complex operations.<br />
The system also manages <strong>Gas Usage</strong> to meter resource consumption, maintains a persistent <strong>State &amp; Database Layer</strong> for account and storage data,<br />
and orchestrates <strong>Frames &amp; Call Handling</strong> for nested contract executions.<br />
An <strong>Execution Loop &amp; Handler</strong> coordinate transaction lifecycle from validation to finalization, while an <strong>Inspector &amp; Tracing</strong> abstraction enables debugging and profiling.<br />
Finally, the <strong>Context &amp; Environment</strong> encapsulate blockchain and transaction data, providing configuration and execution context throughout the EVM lifecycle.</p>
<p><strong>Source Repository:</strong> <a href="Revm/None">None</a></p>
<pre class="mermaid">flowchart TD
    A0[&quot;Interpreter&quot;]
    A1[&quot;Host Interface&quot;]
    A2[&quot;Precompiles&quot;]
    A3[&quot;Bytecode &amp; Opcodes&quot;]
    A4[&quot;Gas Management&quot;]
    A5[&quot;State &amp; Database Layers&quot;]
    A6[&quot;Frame &amp; Call Handling&quot;]
    A7[&quot;Handler &amp; Execution Loop&quot;]
    A8[&quot;Inspector &amp; Tracing&quot;]
    A9[&quot;Context &amp; Environment&quot;]
    A7 -- &quot;Executes&quot; --&gt; A0
    A0 -- &quot;Queries state&quot; --&gt; A1
    A7 -- &quot;Manages gas accounting&quot; --&gt; A4
    A1 -- &quot;Accesses blockchain state&quot; --&gt; A5
    A0 -- &quot;Calls optimized native cont...&quot; --&gt; A2
    A6 -- &quot;Runs interpreter for frames&quot; --&gt; A0
    A7 -- &quot;Manages call stack&quot; --&gt; A6
    A8 -- &quot;Hooks into execution steps&quot; --&gt; A0
    A8 -- &quot;Integrates with handler&quot; --&gt; A7
    A9 -- &quot;Provides blockchain context&quot; --&gt; A1
    A7 -- &quot;Uses execution environment&quot; --&gt; A9
    A0 -- &quot;Parses and executes bytecode&quot; --&gt; A3
    A2 -- &quot;Accesses blockchain data&quot; --&gt; A1
    A4 -- &quot;Provides gas cost info&quot; --&gt; A0
    A5 -- &quot;Backs state queries&quot; --&gt; A1
    A6 -- &quot;Uses execution context&quot; --&gt; A9
    A3 -- &quot;Supplies instruction set&quot; --&gt; A0
</pre>
<h2 id="chapters"><a class="header" href="#chapters">Chapters</a></h2>
<ol>
<li><a href="Revm/./01_context___environment_.html">Context &amp; Environment</a></li>
<li><a href="Revm/./02_host_interface_.html">Host Interface</a></li>
<li><a href="Revm/./03_state___database_layers_.html">State &amp; Database Layers</a></li>
<li><a href="Revm/./04_gas_management_.html">Gas Management</a></li>
<li><a href="Revm/./05_bytecode___opcodes_.html">Bytecode &amp; Opcodes</a></li>
<li><a href="Revm/./06_precompiles_.html">Precompiles</a></li>
<li><a href="Revm/./07_interpreter_.html">Interpreter</a></li>
<li><a href="Revm/./08_frame___call_handling_.html">Frame &amp; Call Handling</a></li>
<li><a href="Revm/./09_handler___execution_loop_.html">Handler &amp; Execution Loop</a></li>
<li><a href="Revm/./10_inspector___tracing_.html">Inspector &amp; Tracing</a></li>
</ol>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1-context--environment"><a class="header" href="#chapter-1-context--environment">Chapter 1: Context &amp; Environment</a></h1>
<p>Welcome to the first chapter of this tutorial on <code>revm</code>! Here, we will explore an important concept called <strong>Context &amp; Environment</strong> — the foundation that lets the EVM ("Ethereum Virtual Machine") understand what’s happening around it while running your smart contracts.</p>
<hr />
<h2 id="why-do-we-need-context--environment"><a class="header" href="#why-do-we-need-context--environment">Why do we need Context &amp; Environment?</a></h2>
<p>Imagine you’re watching a movie. To understand the story, you need to know where it takes place, who’s in it, and what’s going on at the moment. Similarly, the EVM needs to know:</p>
<ul>
<li>Which block it’s working on (block number, gas limits, timestamp, etc.)</li>
<li>Details about the current transaction (sender, value, gas, data)</li>
<li>What configuration rules to apply (like gas rules, chain id)</li>
<li>The current state of accounts and storage (like balances, code, storage values)</li>
<li>Any errors or changes that happen as the contract runs</li>
</ul>
<p>All of this information is wrapped up in something called the <strong>Context</strong>.</p>
<h3 id="real-world-example"><a class="header" href="#real-world-example">Real-world example:</a></h3>
<p>Suppose you want to run a smart contract call that transfers some Ether from one account to another. The EVM needs to:</p>
<ol>
<li>Check the current block’s gas limit.</li>
<li>Access the sender’s balance.</li>
<li>Access the receiver's account.</li>
<li>Deduct gas fees according to the current rules.</li>
<li>Apply the state changes if everything is valid.</li>
</ol>
<p>How can it access all this smoothly? This is where the <strong>Context</strong> steps in — acting like the "window" that the EVM uses to see what's happening on the blockchain during execution.</p>
<hr />
<h2 id="breaking-down-the-context"><a class="header" href="#breaking-down-the-context">Breaking down the Context</a></h2>
<p>Think of the Context as a <strong>big toolbox</strong> with some essential parts inside:</p>
<h3 id="1-block-information"><a class="header" href="#1-block-information">1. Block Information</a></h3>
<ul>
<li>Contains info about the current block:
<ul>
<li>Block number (height)</li>
<li>Beneficiary (miner/coinbase)</li>
<li>Timestamp</li>
<li>Gas limit</li>
<li>Base fee per gas</li>
<li>Special Ethereum upgrades data (like randomness, blob gas info)</li>
</ul>
</li>
</ul>
<p>This info affects how transactions execute because gas limits and fees vary per block.</p>
<h3 id="2-transaction-details"><a class="header" href="#2-transaction-details">2. Transaction Details</a></h3>
<ul>
<li>Info about the transaction currently being executed:
<ul>
<li>Sender/receiver addresses</li>
<li>Value sent</li>
<li>Input data</li>
<li>Gas provided</li>
</ul>
</li>
</ul>
<p>Knowing this helps check funds, replay protection, and other transaction-specific rules.</p>
<h3 id="3-configuration-cfg"><a class="header" href="#3-configuration-cfg">3. Configuration (Cfg)</a></h3>
<ul>
<li>Contains parameters about chain rules and behavior:
<ul>
<li>Which Ethereum hardfork rules are active (i.e., London, Cancun upgrades).</li>
<li>Chain ID</li>
<li>Gas checking toggles</li>
</ul>
</li>
</ul>
<p>This controls what rules are in effect for execution.</p>
<h3 id="4-journaled-state-journal"><a class="header" href="#4-journaled-state-journal">4. Journaled State (Journal)</a></h3>
<ul>
<li>The journaled state is <strong>an advanced way to track changes</strong> made during execution but not commit immediately.</li>
<li>It keeps a record ("journal") of all state changes like account balances and storage so that they can be reverted if needed (for instance, if the contract reverts).</li>
</ul>
<h3 id="5-database-db"><a class="header" href="#5-database-db">5. Database (DB)</a></h3>
<ul>
<li>This is the <strong>underlying storage backend</strong> that holds permanent blockchain state (accounts, storage, code).</li>
<li>The Journal reads from and writes changes to this database through the context.</li>
</ul>
<h3 id="6-errors"><a class="header" href="#6-errors">6. Errors</a></h3>
<ul>
<li>The Context also keeps track of any errors occurring during execution, like missing account data or database issues.</li>
</ul>
<h3 id="7-memory-buffer"><a class="header" href="#7-memory-buffer">7. Memory Buffer</a></h3>
<ul>
<li>A reusable buffer to optimize memory allocations during execution (mostly internal optimization).</li>
</ul>
<hr />
<h2 id="how-to-use-the-context-in-revm"><a class="header" href="#how-to-use-the-context-in-revm">How to use the Context in <code>revm</code>?</a></h2>
<p>Let's look at how you might <strong>create a simple context</strong> for EVM execution, step-by-step.</p>
<h3 id="step-1-create-a-database-for-example-an-empty-one"><a class="header" href="#step-1-create-a-database-for-example-an-empty-one">Step 1: Create a database (for example, an empty one)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::primitives::SpecId; // Ethereum hardfork spec IDs
use revm::context::{Context, EmptyDB};

// Create an empty database — no existing chain data
let db = EmptyDB;
<span class="boring">}</span></code></pre></pre>
<p><em>Here, <code>EmptyDB</code> means we have no existing blockchain data yet.</em></p>
<h3 id="step-2-create-a-context-with-this-database-and-a-spec"><a class="header" href="#step-2-create-a-context-with-this-database-and-a-spec">Step 2: Create a Context with this database and a spec</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spec = SpecId::LATEST;  // Use latest Ethereum rules
let mut ctx = Context::new(db, spec);
<span class="boring">}</span></code></pre></pre>
<p><em>This initializes Context with default empty block, transaction, and configuration info.</em></p>
<h3 id="step-3-update-the-transaction-and-block-info"><a class="header" href="#step-3-update-the-transaction-and-block-info">Step 3: Update the transaction and block info</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ctx.modify_tx(|tx| {
    tx.gas_limit = 10_000_000;
    tx.caller = "0x1234...".parse().unwrap();
    tx.value = 1000.into();
});

ctx.modify_block(|block| {
    block.number = 12_345;
    block.timestamp = 1_676_000_000;
    block.gas_limit = 15_000_000;
});
<span class="boring">}</span></code></pre></pre>
<p><em>Here, we set a fake transaction and block to make the context more real.</em></p>
<h3 id="result"><a class="header" href="#result">Result?</a></h3>
<p>When you run your EVM interpreter using this context, it will:</p>
<ul>
<li>Access the transaction info through <code>ctx.tx()</code></li>
<li>Access the block info through <code>ctx.block()</code></li>
<li>Use config rules from <code>ctx.cfg()</code></li>
<li>Read/write state safely via the <code>ctx.journal()</code></li>
<li>Track errors via <code>ctx.error()</code></li>
</ul>
<p>So, this context acts like the environment your smart contract runs inside.</p>
<hr />
<h2 id="what-happens-inside-context-step-by-step"><a class="header" href="#what-happens-inside-context-step-by-step">What happens inside Context step-by-step?</a></h2>
<p>To imagine this, think of the EVM as a chef baking a cake (executing smart contract code). The Context is the <strong>kitchen with all ingredients and recipes</strong>:</p>
<pre class="mermaid">sequenceDiagram
    participant EVM as EVM Interpreter
    participant CTX as Context (block, tx, cfg, journal, db)
    participant DB as Database (blockchain data)
    participant ERR as Error Tracker

    EVM-&gt;&gt;CTX: Request block &amp; transaction info
    CTX-&gt;&gt;EVM: Return block, tx, cfg details
    EVM-&gt;&gt;CTX.journal: Read/write state changes
    CTX.journal-&gt;&gt;DB: Load/store account &amp; storage data
    CTX.journal-&gt;&gt;CTX: Manage journaling (snapshot/revert)
    EVM-&gt;&gt;CTX.error: Report any errors
    CTX.error-&gt;&gt;EVM: Error state updated
</pre>
<p><strong>Step explanation:</strong></p>
<ol>
<li>The EVM asks the Context for block and transaction info so it knows the current environment.</li>
<li>When the contract modifies states (like balance or storage), it goes through the journal to safely track these changes.</li>
<li>The journal interacts with the actual database to get or update state.</li>
<li>If something goes wrong (like insufficient funds), the error state is updated in Context.</li>
<li>The EVM reads error status from Context to decide what to do (continue, revert, abort).</li>
</ol>
<hr />
<h2 id="peek-under-the-hood-context-struct-in-code"><a class="header" href="#peek-under-the-hood-context-struct-in-code">Peek under the hood: Context Struct in Code</a></h2>
<p>Look at the simplified structure of <code>Context</code> (from <code>crates/context/src/context.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Context&lt;BLOCK, TX, CFG, DB, JOURNAL, CHAIN&gt; {
    pub block: BLOCK,
    pub tx: TX,
    pub cfg: CFG,
    pub journaled_state: JOURNAL,
    pub chain: CHAIN,
    pub memory_buffer: Rc&lt;RefCell&lt;Vec&lt;u8&gt;&gt;&gt;,
    pub error: Result&lt;(), ContextError&lt;DB::Error&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>block</code>: holds the current block info.</li>
<li><code>tx</code>: holds the current transaction info.</li>
<li><code>cfg</code>: holds the chain configuration.</li>
<li><code>journaled_state</code>: the journaling layer managing state changes.</li>
<li><code>chain</code>: represents chain-specific data.</li>
<li><code>memory_buffer</code>: reusable buffer for memory between calls.</li>
<li><code>error</code>: holds the current error (if any).</li>
</ul>
<h3 id="implementation-of-trait-contexttr"><a class="header" href="#implementation-of-trait-contexttr">Implementation of trait <code>ContextTr</code></a></h3>
<p>The trait defines how to get/set these parts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;BLOCK, TX, CFG, DB, JOURNAL, CHAIN&gt; ContextTr for Context&lt;BLOCK, TX, CFG, DB, JOURNAL, CHAIN&gt; {
    // Returns current transaction
    fn tx(&amp;self) -&gt; &amp;Self::Tx {
        &amp;self.tx
    }

    // Returns current block
    fn block(&amp;self) -&gt; &amp;Self::Block {
        &amp;self.block
    }

    // Returns configuration
    fn cfg(&amp;self) -&gt; &amp;Self::Cfg {
        &amp;self.cfg
    }

    // Returns mutable reference to journal for state changes
    fn journal(&amp;mut self) -&gt; &amp;mut Self::Journal {
        &amp;mut self.journaled_state
    }

    // Returns error status
    fn error(&amp;mut self) -&gt; &amp;mut Result&lt;(), ContextError&lt;&lt;Self::Db as Database&gt;::Error&gt;&gt; {
        &amp;mut self.error
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This trait is how all parts talk to each other, keeping the Context clean and modular.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What is Context &amp; Environment?</strong><br />
It is the collection of all relevant blockchain info EVM needs while running code.</p>
</li>
<li>
<p><strong>Why is it important?</strong><br />
It lets the EVM safely access block, transaction, config, and the current state, while also being able to track any execution errors.</p>
</li>
<li>
<p><strong>What key parts does Context include?</strong><br />
Block info, transaction info, configuration, journaled state, database, errors, and some internal buffers.</p>
</li>
<li>
<p><strong>How does Context help EVM execution?</strong><br />
It acts like a "window" for the EVM into the blockchain at execution time.</p>
</li>
<li>
<p><strong>How to create and update a Context?</strong><br />
Using the <code>Context::new</code> method, plus <code>modify_tx</code>, <code>modify_block</code>, and so on.</p>
</li>
<li>
<p><strong>What happens inside Context?</strong><br />
It fetches data from the database, keeps track of state changes via journaling, and reports errors back to the EVM.</p>
</li>
</ul>
<hr />
<p>Next, we will explore how the EVM uses this Context to interact with the host and lower-level blockchain interfaces. Check out <a href="Revm/02_host_interface_.html">Chapter 2: Host Interface</a> to dive into that!</p>
<hr />
<p>Thank you for following along! The Context is your first step into understanding how revm manages the intricacies of blockchain execution. Keep up the great work!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-host-interface"><a class="header" href="#chapter-2-host-interface">Chapter 2: Host Interface</a></h1>
<p>Welcome back! In <a href="Revm/01_context___environment_.html">Chapter 1: Context &amp; Environment</a>, we explored how the EVM understands the blockchain world around it with block info, transaction details, configuration, and state. Now, we dive deeper into the <strong>Host Interface</strong> — the bridge that connects the EVM interpreter to this external blockchain environment.</p>
<hr />
<h2 id="why-do-we-need-a-host-interface"><a class="header" href="#why-do-we-need-a-host-interface">Why do we need a Host Interface?</a></h2>
<p>Imagine you’re trying to run a smart contract — like a digital vending machine. When someone sends an order (a transaction), your vending machine needs to check several things:</p>
<ul>
<li>How much money does the buyer have?</li>
<li>What items are in stock?</li>
<li>What’s the current price for an item? (which might depend on block info)</li>
<li>If the buyer pays, deduct money and add items to their inventory.</li>
<li>Create a log or event that says “Item sold”.</li>
</ul>
<p>The EVM itself only understands how to run contract code step-by-step. It doesn’t know anything about your blockchain's accounts, balances, or logs — it only sees the code and data you feed it.</p>
<p><strong>The Host Interface is the "operating system" for the EVM</strong>, answering its "system calls" to get or change blockchain data like accounts, storage, balance, block info, and logs.</p>
<hr />
<h2 id="a-concrete-use-case-running-a-contract-call-that-changes-storage"><a class="header" href="#a-concrete-use-case-running-a-contract-call-that-changes-storage">A Concrete Use Case: Running a Contract Call That Changes Storage</a></h2>
<p>Let’s break down what happens when a smart contract updates a storage value during execution:</p>
<ol>
<li>The EVM reads the current storage value at a certain key for an address.</li>
<li>The EVM modifies the storage with a new value.</li>
<li>The EVM may write logs for events or handle self-destruct (contract deletion).</li>
<li>The Host Interface takes care of reading/writing all this to keep the blockchain state correct.</li>
</ol>
<p>The Host Interface provides a clean set of functions to access and modify this information. Instead of the EVM talking directly to the blockchain database, it uses the Host trait that <strong>knows how to safely interact with the blockchain state via the Context</strong>.</p>
<hr />
<h2 id="what-does-the-host-interface-provide"><a class="header" href="#what-does-the-host-interface-provide">What Does the Host Interface Provide?</a></h2>
<p>The host can be thought of as a <strong>service desk</strong> that the EVM talks to with requests, such as:</p>
<ul>
<li><strong>Get block information:</strong> What’s the block number? What’s the base fee?</li>
<li><strong>Get transaction information:</strong> Who sent this transaction?</li>
<li><strong>Access blockchain state:</strong>
<ul>
<li>Account balances</li>
<li>Contract code and code hash</li>
<li>Storage values</li>
<li>Self-destruct accounts (deletion)</li>
</ul>
</li>
<li><strong>Handle logs:</strong> Record events emitted by contracts</li>
<li><strong>Manage transient storage:</strong> Temporary storage used during execution</li>
<li><strong>Deal with gas-related data and configuration</strong></li>
</ul>
<hr />
<h2 id="host-interface--key-functions-at-a-glance"><a class="header" href="#host-interface--key-functions-at-a-glance">Host Interface – Key Functions at a Glance</a></h2>
<p>Let's see some key operations that the host supports, in beginner-friendly terms:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>What it does</th></tr></thead><tbody>
<tr><td><code>basefee()</code></td><td>Returns current block’s base gas fee</td></tr>
<tr><td><code>caller()</code></td><td>Returns the address that called the contract</td></tr>
<tr><td><code>balance(address)</code></td><td>Returns the balance of an account</td></tr>
<tr><td><code>sload(address, key)</code></td><td>Reads a storage value at a specific location</td></tr>
<tr><td><code>sstore(address, key, val)</code></td><td>Writes a new storage value</td></tr>
<tr><td><code>log(log)</code></td><td>Emits a log/event</td></tr>
<tr><td><code>selfdestruct(address, target)</code></td><td>Marks a contract for deletion, funds sent to target</td></tr>
</tbody></table>
</div>
<p>These functions enable the EVM to read and write the blockchain state without knowing how the underlying data is stored or managed.</p>
<hr />
<h2 id="how-to-use-the-host-interface-in-practice"><a class="header" href="#how-to-use-the-host-interface-in-practice">How to Use the Host Interface in Practice?</a></h2>
<p>The <code>Host</code> trait is implemented for any type that has a <code>ContextTr</code> (which we learned about in Chapter 1).</p>
<p>Here's a very minimal example showing how the host can be used through this trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assume `ctx` is our initialized Context from Chapter 1
let base_fee = ctx.basefee();
println!("Current block basefee: {}", base_fee);

// Get caller (transaction sender)
let caller = ctx.caller();
println!("Transaction caller: {:?}", caller);

// Read a storage value from contract at address zero (simplified example)
let key = U256::ZERO;
if let Some(storage_val) = ctx.sload(Address::ZERO, key) {
    println!("Storage value at key 0: {}", storage_val.value);
} else {
    println!("No storage value found.");
}

// Store a new value in contract storage
let _ = ctx.sstore(Address::ZERO, key, U256::from(42));
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li><code>basefee()</code> gets the current base fee for the block.</li>
<li><code>caller()</code> shows who sent the transaction.</li>
<li><code>sload()</code> reads a value from the contract's storage.</li>
<li><code>sstore()</code> writes a new value into the contract's storage.</li>
</ul>
</blockquote>
<p>Behind these scenes, the host safely manages reads and writes using the journaled state and the underlying database, handling errors if things go wrong.</p>
<hr />
<h2 id="what-happens-inside-the-host-interface-step-by-step"><a class="header" href="#what-happens-inside-the-host-interface-step-by-step">What Happens Inside the Host Interface? (Step-by-Step)</a></h2>
<p>Let's visualize how the EVM uses the Host interface when it needs data:</p>
<pre class="mermaid">sequenceDiagram
    participant EVM as EVM Interpreter
    participant Host as Host Interface (via Context)
    participant Journal as Journaled State
    participant DB as Blockchain Database
    participant Errors as Error Tracker

    EVM-&gt;&gt;Host: Request storage value (sload)
    Host-&gt;&gt;Journal: Check journal for latest value
    Journal-&gt;&gt;DB: If not in journal, load from DB
    DB--&gt;&gt;Journal: Return storage value
    Journal--&gt;&gt;Host: Return storage value with cold/hot info
    Host--&gt;&gt;EVM: Returns storage value

    EVM-&gt;&gt;Host: Request to update storage (sstore)
    Host-&gt;&gt;Journal: Apply storage change (with journaling)
    Journal--&gt;&gt;DB: Update deferred until commit
    Host-&gt;&gt;Errors: Any error while updating?
</pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li>The EVM asks the Host for storage data.</li>
<li>The Host checks if the value is already in the journal (recently read/modified during this execution).</li>
<li>If not, the journal asks the database for the data.</li>
<li>The journal returns the value to the Host, which returns it to the EVM.</li>
<li>When the EVM writes new storage values, the Host ensures the change is recorded in the journal with the ability to revert later if needed.</li>
<li>Any errors (like permission denied or missing data) are tracked and reported to the EVM via the Host.</li>
</ul>
<hr />
<h2 id="under-the-hood-how-is-host-implemented"><a class="header" href="#under-the-hood-how-is-host-implemented">Under the Hood: How Is Host Implemented?</a></h2>
<p>The central piece is the <code>Host</code> trait defined around the <code>ContextTr</code> abstraction we met earlier.</p>
<p>Here's a simplified overview showing how <code>Host</code> methods delegate to the parts inside <code>Context</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Host {
    // Block info
    fn basefee(&amp;self) -&gt; U256;

    // Transaction info
    fn caller(&amp;self) -&gt; Address;

    // State access
    fn sload(&amp;mut self, address: Address, key: U256) -&gt; Option&lt;StateLoad&lt;U256&gt;&gt;;
    fn sstore(&amp;mut self, address: Address, key: U256, value: U256) -&gt; Option&lt;StateLoad&lt;SStoreResult&gt;&gt;;

    // Logs &amp; selfdestruct
    fn log(&amp;mut self, log: Log);
    fn selfdestruct(&amp;mut self, address: Address, target: Address) -&gt; Option&lt;StateLoad&lt;SelfDestructResult&gt;&gt;;
}

// Implementation for any ContextTr type
impl&lt;CTX: ContextTr&gt; Host for CTX {
    fn basefee(&amp;self) -&gt; U256 {
        U256::from(self.block().basefee())
    }

    fn caller(&amp;self) -&gt; Address {
        self.tx().caller()
    }

    fn sload(&amp;mut self, address: Address, key: U256) -&gt; Option&lt;StateLoad&lt;U256&gt;&gt; {
        self.journal()
            .sload(address, key)
            .ok()
    }

    fn sstore(&amp;mut self, address: Address, key: U256, value: U256) -&gt; Option&lt;StateLoad&lt;SStoreResult&gt;&gt; {
        self.journal()
            .sstore(address, key, value)
            .ok()
    }

    fn log(&amp;mut self, log: Log) {
        self.journal().log(log);
    }

    fn selfdestruct(&amp;mut self, address: Address, target: Address) -&gt; Option&lt;StateLoad&lt;SelfDestructResult&gt;&gt; {
        self.journal().selfdestruct(address, target).ok()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="explanation-1"><a class="header" href="#explanation-1">Explanation:</a></h3>
<ul>
<li>The Host trait reads block info and transaction info directly from the <code>Context</code>’s block and transaction.</li>
<li>Storage reads and writes go through the journal (<code>self.journal()</code>), which wraps interaction with the underlying database and state tracking.</li>
<li>Logging and contract self-destruction are also handled by the journal layer.</li>
<li>Errors during any of these operations update the error state inside the Context.</li>
</ul>
<hr />
<h2 id="a-dummy-host-the-simplest-possible-host"><a class="header" href="#a-dummy-host-the-simplest-possible-host">A Dummy Host: The Simplest Possible Host</a></h2>
<p>For testing or simple cases, there's a <code>DummyHost</code> that fulfills the host interface with no actual data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DummyHost;

impl Host for DummyHost {
    fn basefee(&amp;self) -&gt; U256 { U256::ZERO }
    fn caller(&amp;self) -&gt; Address { Address::ZERO }
    fn sload(&amp;mut self, _address: Address, _key: U256) -&gt; Option&lt;StateLoad&lt;U256&gt;&gt; { None }
    fn sstore(&amp;mut self, _address: Address, _key: U256, _value: U256) -&gt; Option&lt;StateLoad&lt;SStoreResult&gt;&gt; { None }
    fn log(&amp;mut self, _log: Log) {}
    fn selfdestruct(&amp;mut self, _address: Address, _target: Address) -&gt; Option&lt;StateLoad&lt;SelfDestructResult&gt;&gt; { None }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>This dummy host returns zero values or none for all calls, which helps in unit tests or understanding the interface without real blockchain data.</p>
</blockquote>
<hr />
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What is the Host Interface?</strong><br />
The bridge between the EVM interpreter and the external blockchain environment, handling all requests to blockchain data and state.</p>
</li>
<li>
<p><strong>Why is it important?</strong><br />
It abstracts the complexity of reading/writing blockchain state safely and consistently during contract execution.</p>
</li>
<li>
<p><strong>What key features does it provide?</strong><br />
Access to block info, transaction info, contract storage, balances, self-destructs, logs, and configuration.</p>
</li>
<li>
<p><strong>How is it used?</strong><br />
The EVM calls Host methods like <code>sload</code>, <code>sstore</code>, <code>balance</code>, etc., without needing to know internal blockchain data structures.</p>
</li>
<li>
<p><strong>What happens internally?</strong><br />
The Host delegates calls to the journaled state and the underlying database, tracks errors, and ensures state consistency during execution.</p>
</li>
<li>
<p><strong>The Host is implemented as a Rust trait for the Context, making it highly modular and flexible.</strong></p>
</li>
</ul>
<hr />
<p>Next, we will go deeper into how <code>revm</code> manages blockchain state using various layers with journaling and databases. If you're curious about how the state is organized and tracked internally, continue with <a href="Revm/03_state___database_layers_.html">Chapter 3: State &amp; Database Layers</a>.</p>
<hr />
<p>Thank you for sticking with me! The Host Interface is the essential connection that powers safe and smooth smart contract execution. Keep exploring!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-state--database-layers"><a class="header" href="#chapter-3-state--database-layers">Chapter 3: State &amp; Database Layers</a></h1>
<p>Welcome back! In <a href="Revm/02_host_interface_.html">Chapter 2: Host Interface</a>, we learned how the EVM talks to the blockchain environment to read account balances, storage, and block info. Now, we’ll dig deeper into <strong>how the blockchain state is actually stored, organized, and updated inside revm</strong>.</p>
<hr />
<h2 id="why-do-we-need-state--database-layers"><a class="header" href="#why-do-we-need-state--database-layers">Why do we need State &amp; Database Layers?</a></h2>
<p>Imagine you’re managing a huge library. Visitors can borrow books, return them, or add new ones. You need a system that:</p>
<ul>
<li>Remembers who owns what book.</li>
<li>Keeps track of books available on the shelves.</li>
<li>Allows you to update records in real-time.</li>
<li>Lets you rollback changes if a mistake happens.</li>
</ul>
<p>In Ethereum (and thus in EVM), the "library" is the <strong>blockchain state</strong>: all accounts, their balances, nonces, smart contract code, and storage (key-value data inside contracts).</p>
<p>The <strong>State &amp; Database Layers</strong> in revm handle:</p>
<ul>
<li>Loading this data from some permanent storage (database).</li>
<li>Caching it while the EVM is executing (so repeated reads are fast).</li>
<li>Managing changes safely, so they can be committed or reverted.</li>
<li>Organizing account details, storage slots, and bytecode in structures that are efficient and easy to update.</li>
</ul>
<p>In short: <strong>This is the persistent storage backend for the EVM</strong>, where everything that smart contracts read/write really “lives.”</p>
<hr />
<h2 id="a-concrete-scenario-reading-and-updating-account-storage"><a class="header" href="#a-concrete-scenario-reading-and-updating-account-storage">A Concrete Scenario: Reading and Updating Account Storage</a></h2>
<p>Let’s say a smart contract running in the EVM wants to:</p>
<ol>
<li>Read the current value stored at a specific key in its storage.</li>
<li>Modify that value to a new number.</li>
<li>Deduct some balance from the sender account.</li>
<li>Update the nonce to prevent replay.</li>
<li>Eventually commit all these changes to make them permanent.</li>
</ol>
<p>How do we organize this flow so the EVM can do all those steps efficiently and safely?</p>
<p>The State &amp; Database Layers provide this solution.</p>
<hr />
<h2 id="key-concepts-in-state--database-layers"><a class="header" href="#key-concepts-in-state--database-layers">Key Concepts in State &amp; Database Layers</a></h2>
<p>Let’s break down the building blocks of this system in simple terms:</p>
<h3 id="1-database"><a class="header" href="#1-database">1. <strong>Database</strong></a></h3>
<ul>
<li>Think of this as the <strong>permanent filing cabinet</strong>.</li>
<li>It holds <em>all</em> the accounts and their data before any new transaction runs.</li>
<li>It stores:
<ul>
<li>Account information: balances, nonces, code hash.</li>
<li>Contract bytecode.</li>
<li>Storage key-value pairs for each account.</li>
<li>Block hashes by block number.</li>
</ul>
</li>
<li>Usually, it is slow to access because it might be on disk or remote.</li>
</ul>
<p><strong>Example:</strong> <code>EmptyDB</code> is a built-in simple database that acts like an empty filing cabinet with default empty data. It is mostly used for testing.</p>
<hr />
<h3 id="2-cache-layer"><a class="header" href="#2-cache-layer">2. <strong>Cache Layer</strong></a></h3>
<ul>
<li>Think of this as your <strong>desktop where you keep frequently used files</strong>.</li>
<li>The cache stores data that has been loaded from the database.</li>
<li>It allows fast repeated reads and quick writes <em>before committing</em> changes.</li>
<li>It holds accounts and storage slots that the EVM reads or modifies during execution.</li>
<li>It also keeps track of logs and modified contract bytecode.</li>
</ul>
<p><strong>Example:</strong> <code>CacheDB</code> is a cache implementation that wraps a database. It will first check cache entries before asking the database.</p>
<hr />
<h3 id="3-state"><a class="header" href="#3-state">3. <strong>State</strong></a></h3>
<ul>
<li>The <strong>“state”</strong> is the interface exposed to the EVM to <strong>read and write blockchain data</strong>.</li>
<li>It hides the complexity of caching and persistent storage behind simple calls.</li>
<li>State manages:
<ul>
<li>Loading accounts when needed.</li>
<li>Reading/writing storage slots.</li>
<li>Committing or reverting changes after execution.</li>
</ul>
</li>
<li>It supports transitions, which are the changes during a transaction or block.</li>
</ul>
<hr />
<h3 id="4-transition-state--bundle"><a class="header" href="#4-transition-state--bundle">4. <strong>Transition State &amp; Bundle</strong></a></h3>
<ul>
<li>To support rollbacks, the system stores <strong>“transitions”</strong> — changes made during transaction execution that are <em>not</em> yet final.</li>
<li>If the transaction fails or reverts, these can be discarded.</li>
<li>Completed transitions are merged into a <strong>“bundle”</strong>, which represents a finalized snapshot of state changes after a block.</li>
<li>This approach ensures history and safety in state updates.</li>
</ul>
<hr />
<h2 id="what-does-this-layer-look-like-in-code"><a class="header" href="#what-does-this-layer-look-like-in-code">What Does This Layer Look Like in Code?</a></h2>
<p>Here’s a minimal snippet creating an empty cache wrapping an empty database and reading an account info:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::database::{CacheDB, EmptyDB};
use primitives::Address;

// Create an empty database — no data yet
let db = EmptyDB::default();

// Wrap it with a cache for faster access
let mut cache_db = CacheDB::new(db);

// Pick an address (all zeros here for example)
let address = Address::zero();

// Try to get account data (balance, nonce)
let account_info = cache_db.basic(address).unwrap();

println!("Account info for {:?}: {:?}", address, account_info);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li>We create an empty database with no accounts.</li>
<li>Wrap it in a cache so if we add data later it will be stored in-memory first.</li>
<li>Query account basic info. For an empty database this will be <code>None</code>.</li>
<li>This shows reading from the database with caching.</li>
</ul>
</blockquote>
<hr />
<h2 id="reading-and-updating-storage-example"><a class="header" href="#reading-and-updating-storage-example">Reading and Updating Storage Example</a></h2>
<p>Let’s simulate loading a storage slot and then updating it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use primitives::{Address, U256};

// The address and storage slot key we want to access
let address = Address::zero();
let storage_key = U256::zero();

// Read from storage (returns U256::ZERO if missing)
let value_before = cache_db.storage(address, storage_key).unwrap();
println!("Old storage value: {}", value_before);

// Update the storage value — say setting it to 42
cache_db.insert_account_storage(address, storage_key, U256::from(42)).unwrap();

// Read again, now it should return 42
let value_after = cache_db.storage(address, storage_key).unwrap();
println!("New storage value: {}", value_after);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li>We read storage key <code>0</code> for <code>address 0x0</code>. It returns the stored value or zero if not present.</li>
<li>We then insert a new storage value (<code>42</code>) to the in-memory cache.</li>
<li>Reading again shows the updated value.</li>
</ul>
<p><strong>Note:</strong> These changes are in-memory only until committed.</p>
</blockquote>
<hr />
<h2 id="committing-state-changes"><a class="header" href="#committing-state-changes">Committing State Changes</a></h2>
<p>After all updates are done (e.g., EVM execution succeeded), the cache can be committed or merged with the underlying database.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use primitives::HashMap;
use state::Account;

// Prepare changes to commit
let mut changes = HashMap::new();

// Here suppose we create a simple account change for address
let account_change = Account {
    info: /* updated AccountInfo */,
    storage: /* updated storage HashMap */,
};

changes.insert(address, account_change);

// Commit changes to cache_db
cache_db.commit(changes);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li>This example shows you can batch changes into a <code>HashMap</code> of updated accounts.</li>
<li>Committing will update the cache with the latest info, preparing it for final persistence.</li>
<li>Typically the database commit happens after the full block/transaction batch.</li>
</ul>
</blockquote>
<hr />
<h2 id="what-happens-internally-step-by-step-flow"><a class="header" href="#what-happens-internally-step-by-step-flow">What Happens Internally? Step-by-step Flow</a></h2>
<p>Imagine the EVM requests a storage value or updates account balance during execution:</p>
<pre class="mermaid">sequenceDiagram
    participant EVM as EVM Interpreter
    participant State as State Layer
    participant Cache as Cache Layer
    participant DB as Persistent Database

    EVM-&gt;&gt;State: Request storage at (address, key)
    State-&gt;&gt;Cache: Check cached storage slot
    alt Storage in cache
        Cache--&gt;&gt;State: Return cached value
    else Storage not in cache
        Cache-&gt;&gt;DB: Load storage slot value
        DB--&gt;&gt;Cache: Return storage value
        Cache--&gt;&gt;State: Return loaded value
    end
    State--&gt;&gt;EVM: Provide storage value

    EVM-&gt;&gt;State: Update storage at (address, key) with new value
    State-&gt;&gt;Cache: Store new value in cache (in-memory)
    Cache--&gt;&gt;State: Confirm update
    State--&gt;&gt;EVM: Update successful

    EVM-&gt;&gt;State: Commit changes after execution
    State-&gt;&gt;Cache: Merge changes into database or flush
    Cache-&gt;&gt;DB: Write updated accounts and storage persistently
    DB--&gt;&gt;Cache: Confirm commit
    Cache--&gt;&gt;State: Commit successful
    State--&gt;&gt;EVM: Changes finalized
</pre>
<hr />
<h2 id="under-the-hood-how-does-revm-implement-this"><a class="header" href="#under-the-hood-how-does-revm-implement-this">Under the Hood: How Does revm Implement This?</a></h2>
<p>Let’s peek inside the main pieces with simplified code excerpts and explanations.</p>
<hr />
<h3 id="1-database-trait"><a class="header" href="#1-database-trait">1. <strong>Database Trait</strong></a></h3>
<p>The <code>Database</code> trait defines the low-level interface any database must provide:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Database {
    type Error;

    fn basic(&amp;mut self, address: Address) -&gt; Result&lt;Option&lt;AccountInfo&gt;, Self::Error&gt;;
    fn code_by_hash(&amp;mut self, code_hash: B256) -&gt; Result&lt;Bytecode, Self::Error&gt;;
    fn storage(&amp;mut self, address: Address, index: U256) -&gt; Result&lt;U256, Self::Error&gt;;
    fn block_hash(&amp;mut self, number: u64) -&gt; Result&lt;B256, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>basic</code> returns basic info about an account (balance, nonce, etc.).</li>
<li><code>code_by_hash</code> returns the contract bytecode for a hash.</li>
<li><code>storage</code> returns the value stored at a particular slot.</li>
<li><code>block_hash</code> returns historic block hash.</li>
</ul>
<hr />
<h3 id="2-emptydb-a-minimal-implementation"><a class="header" href="#2-emptydb-a-minimal-implementation">2. <strong>EmptyDB: A Minimal Implementation</strong></a></h3>
<p>Here's how <code>EmptyDB</code> behaves: all queries return empty/default values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Database for EmptyDB {
    type Error = Infallible;

    fn basic(&amp;mut self, _address: Address) -&gt; Result&lt;Option&lt;AccountInfo&gt;, Self::Error&gt; {
        Ok(None) // No accounts exist
    }

    fn code_by_hash(&amp;mut self, _code_hash: B256) -&gt; Result&lt;Bytecode, Self::Error&gt; {
        Ok(Bytecode::default()) // Empty code
    }

    fn storage(&amp;mut self, _address: Address, _index: U256) -&gt; Result&lt;U256, Self::Error&gt; {
        Ok(U256::ZERO) // Storage empty by default
    }

    fn block_hash(&amp;mut self, number: u64) -&gt; Result&lt;B256, Self::Error&gt; {
        // Deterministic hash of block number (for tests)
        Ok(keccak256(number.to_string().as_bytes()))
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Why is this useful?</strong><br />
It can be used for testing without any real blockchain data.</p>
</blockquote>
<hr />
<h3 id="3-cachedb-the-cache-layer"><a class="header" href="#3-cachedb-the-cache-layer">3. <strong>CacheDB: The Cache Layer</strong></a></h3>
<p><code>CacheDB</code> sits on top of any database and stores in-memory copies of accounts and storage.</p>
<p>Example of loading an account or filling cache if missing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB: DatabaseRef&gt; CacheDB&lt;ExtDB&gt; {
    pub fn load_account(&amp;mut self, address: Address) -&gt; Result&lt;&amp;mut DbAccount, ExtDB::Error&gt; {
        if let Some(account) = self.cache.accounts.get_mut(&amp;address) {
            return Ok(account);
        }
        // Load from database if not cached
        let info = self.db.basic_ref(address)?;
        let db_account = info.map(DbAccount::from).unwrap_or_else(DbAccount::new_not_existing);
        self.cache.accounts.insert(address, db_account);
        self.cache.accounts.get_mut(&amp;address).unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Checks if the account is cached; if not, loads from the underlying database.</li>
<li>Stores it in the cache for faster future access.</li>
<li>Storage slots inside accounts are also cached similarly.</li>
</ul>
<hr />
<h3 id="4-reading-storage-in-cache"><a class="header" href="#4-reading-storage-in-cache">4. <strong>Reading Storage in Cache</strong></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB: DatabaseRef&gt; CacheDB&lt;ExtDB&gt; {
    pub fn storage(&amp;mut self, address: Address, index: U256) -&gt; Result&lt;U256, ExtDB::Error&gt; {
        let account = self.load_account(address)?;
        if let Some(value) = account.storage.get(&amp;index) {
            Ok(*value)
        } else {
            // If storage is unknown, fetch from DB and cache it
            let value = self.db.storage_ref(address, index)?;
            account.storage.insert(index, value);
            Ok(value)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Looks up storage key in the cached account.</li>
<li>If missing, loads from database and caches for later.</li>
</ul>
<hr />
<h3 id="5-inserting-or-updating-storage"><a class="header" href="#5-inserting-or-updating-storage">5. <strong>Inserting or Updating Storage</strong></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB&gt; CacheDB&lt;ExtDB&gt; {
    pub fn insert_account_storage(&amp;mut self, address: Address, slot: U256, value: U256) -&gt; Result&lt;(), ExtDB::Error&gt; {
        let account = self.load_account(address)?;
        account.storage.insert(slot, value);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Updates the storage slot directly in the cache.</li>
<li>Changes are kept in memory, not persisted immediately.</li>
</ul>
<hr />
<h3 id="6-commit-changes"><a class="header" href="#6-commit-changes">6. <strong>Commit Changes</strong></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB: DatabaseCommit&gt; DatabaseCommit for CacheDB&lt;ExtDB&gt; {
    fn commit(&amp;mut self, changes: HashMap&lt;Address, Account&gt;) {
        for (address, account) in changes {
            if account.is_selfdestructed() {
                // Clear account and storage
                let db_account = self.cache.accounts.entry(address).or_default();
                db_account.storage.clear();
                db_account.info = AccountInfo::default();
                continue;
            }

            self.insert_contract(&amp;mut account.info);

            // Update cached account
            self.cache.accounts.insert(address, DbAccount::from(account.info));
            // Update storage slots as well
            // Simplified here for brevity
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Applies a batch of account changes to the cache.</li>
<li>Handles contract creation, deletion, and storage update.</li>
<li>Commit to the underlying database happens after merging bundles or finalization.</li>
</ul>
<hr />
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>In this chapter you learned:</p>
<ul>
<li>
<p><strong>Why State &amp; Database Layers exist:</strong><br />
They provide the persistent storage backend that holds account balances, nonces, contract code, and storage slots.</p>
</li>
<li>
<p><strong>Key components:</strong></p>
<ul>
<li><code>Database</code>: permanent storage interface</li>
<li><code>CacheDB</code>: in-memory cache wrapping the database for fast reads/writes</li>
<li><code>State</code>: manages cached data, transitions, and bundling changes</li>
<li>Transitions &amp; Bundles: for supporting rollbacks and batching block changes</li>
</ul>
</li>
<li>
<p><strong>How EVM reads and writes data:</strong><br />
State tries to read from cache, then falls back on the database. Writes go to cache and are merged before committing.</p>
</li>
<li>
<p><strong>How the commit process works:</strong><br />
Changes are batched and committed, enabling safe state transitions during blocks.</p>
</li>
</ul>
<p>Understanding these layers helps you grasp how revm efficiently manages the "world state" your contracts interact with!</p>
<hr />
<p>Up next, we will explore how the EVM manages gas during execution — from simple counting to advanced rules. Stay tuned for <a href="Revm/04_gas_management_.html">Chapter 4: Gas Management</a>!</p>
<hr />
<p>Thank you for following along! You’re getting deeper into the inner workings of revm, and with this, you now know where the blockchain state really lives and how it changes safely. Keep going!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-gas-management"><a class="header" href="#chapter-4-gas-management">Chapter 4: Gas Management</a></h1>
<p>Welcome back! In the previous chapter, <a href="Revm/03_state___database_layers_.html">State &amp; Database Layers</a>, we uncovered how the blockchain state is stored and managed safely inside <code>revm</code>. Now, let's explore another crucial part that powers Ethereum smart contracts: <strong>Gas Management</strong>.</p>
<hr />
<h2 id="why-do-we-need-gas-management"><a class="header" href="#why-do-we-need-gas-management">Why do we need Gas Management?</a></h2>
<p>Imagine you're driving a car. Your car has a fuel gauge to measure how much fuel (gas) you have left. If you run out of fuel, you’ll stall and wouldn’t be able to continue your journey.</p>
<p>The <strong>Ethereum Virtual Machine (EVM)</strong> works similarly but instead of fuel, it uses <strong>gas</strong>. Gas is the “payment” and “measurement” unit for computational steps and resource usage when running contract code.</p>
<h3 id="a-simple-use-case"><a class="header" href="#a-simple-use-case">A simple use case:</a></h3>
<p>Suppose you want to execute a smart contract function that transfers tokens:</p>
<ul>
<li>Every operation (like a transfer, storage write, or calculation) <strong>costs gas</strong>.</li>
<li>You send a transaction with a <strong>gas limit</strong> — the maximum gas you’re willing to pay.</li>
<li>As instructions are executed, the gas is <strong>spent</strong>.</li>
<li>If gas runs out <strong>before</strong> the contract finishes, the transaction will <strong>fail</strong>.</li>
<li>Some operations can <strong>refund</strong> gas, like freeing storage.</li>
<li>At the end, leftover gas is returned, and the sender only pays for gas actually used.</li>
</ul>
<p><strong>Gas Management</strong> is the part of <code>revm</code> that tracks gas usage, refunds, and checks that you do not overspend your gas limit. It’s the fuel gauge of the EVM ensuring proper payment for execution.</p>
<hr />
<h2 id="breaking-down-gas-management-key-concepts"><a class="header" href="#breaking-down-gas-management-key-concepts">Breaking down Gas Management: Key Concepts</a></h2>
<p>To understand Gas Management, let's break it down into simple pieces:</p>
<h3 id="1-gas-limit"><a class="header" href="#1-gas-limit">1. Gas Limit</a></h3>
<ul>
<li>The <strong>total amount of gas</strong> allowed at the start of execution.</li>
<li>This comes from the transaction parameters.</li>
<li>Think of it as the <strong>full fuel tank</strong> before the journey.</li>
</ul>
<h3 id="2-gas-remaining"><a class="header" href="#2-gas-remaining">2. Gas Remaining</a></h3>
<ul>
<li>How much gas is <strong>left</strong> as instructions execute.</li>
<li>Every EVM instruction subtracts some gas.</li>
<li>If it hits zero or goes below, the transaction <strong>runs out of gas</strong>.</li>
</ul>
<h3 id="3-gas-refunded"><a class="header" href="#3-gas-refunded">3. Gas Refunded</a></h3>
<ul>
<li>Some special actions, like freeing storage space, <strong>refund gas</strong> back.</li>
<li>Refunds are collected during execution but applied only <strong>after</strong> it finishes.</li>
</ul>
<h3 id="4-gas-spent"><a class="header" href="#4-gas-spent">4. Gas Spent</a></h3>
<ul>
<li>The total gas actually used (gas limit - gas remaining).</li>
</ul>
<h3 id="5-memory-gas"><a class="header" href="#5-memory-gas">5. Memory Gas</a></h3>
<ul>
<li>Expanding EVM memory costs gas.</li>
<li>Gas Management tracks how memory usage grows and charges accordingly.</li>
</ul>
<hr />
<h2 id="using-gas-management-a-simple-example"><a class="header" href="#using-gas-management-a-simple-example">Using Gas Management: A Simple Example</a></h2>
<p>Let’s see how we can create and manage gas inside <code>revm</code> with minimal code.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::interpreter::Gas;

// Create gas tracker with a limit of 1,000,000 gas units
let mut gas = Gas::new(1_000_000);

// Check starting gas
println!("Gas limit: {}", gas.limit());          // 1000000
println!("Gas remaining: {}", gas.remaining());  // 1000000

// Spend 21000 gas for a transaction base cost (example)
let success = gas.record_cost(21_000);
println!("Spent 21000 gas: {}", success);
println!("Gas remaining now: {}", gas.remaining());  // 979000

// Attempt to spend 1,000,000 gas - should fail (out of gas)
let success = gas.record_cost(1_000_000);
println!("Spend 1,000,000 gas success? {}", success);  // false

// Record a gas refund of 5,000
gas.record_refund(5_000);
println!("Refunded gas: {}", gas.refunded());  // 5000

// Calculate total gas spent minus refund
println!("Net gas spent: {}", gas.spent_sub_refunded());  // 21000 - 5000 = 16000
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>What happens here?</strong></p>
<ul>
<li>We create a gas tracker with a 1 million unit limit.</li>
<li>Spend 21,000 gas (typical intrinsic cost).</li>
<li>Trying to spend beyond gas limit fails safely.</li>
<li>Gas refunds are recorded but applied later.</li>
<li>Final net gas spent accounts for refunds.</li>
</ul>
</blockquote>
<hr />
<h2 id="what-happens-behind-the-scenes-step-by-step"><a class="header" href="#what-happens-behind-the-scenes-step-by-step">What happens behind the scenes? (Step-by-step)</a></h2>
<p>When the EVM executes operations, it calls Gas Management like this:</p>
<pre class="mermaid">sequenceDiagram
    participant EVM as EVM Interpreter
    participant GAS as Gas Tracker
    participant MEMORY as Memory Tracker
    participant REFUNDS as Refund Tracker

    EVM-&gt;&gt;GAS: Request to spend gas (cost: X)
    alt Enough gas remaining
        GAS-&gt;&gt;GAS: Decrease gas remaining by X
        GAS--&gt;&gt;EVM: Confirm spending
    else Out of gas
        GAS--&gt;&gt;EVM: Fail execution (out of gas)
    end

    EVM-&gt;&gt;MEMORY: Use memory
    MEMORY-&gt;&gt;GAS: Calculate expansion gas cost
    GAS-&gt;&gt;GAS: Deduct memory expansion gas
    GAS--&gt;&gt;EVM: Confirm

    EVM-&gt;&gt;REFUNDS: Emit refund (e.g., clearing storage)
    REFUNDS-&gt;&gt;GAS: Add to refund tally

    EVM-&gt;&gt;GAS: Execution ends, calculate final gas spent accounting refunds
</pre>
<h3 id="explanation-2"><a class="header" href="#explanation-2">Explanation:</a></h3>
<ul>
<li>Every instruction asks the gas tracker if it can spend X gas.</li>
<li>The gas tracker checks if enough gas remains.</li>
<li>For memory usage increases, gas is additionally charged.</li>
<li>Some operations refund gas, which are tracked separately.</li>
<li>At the end of execution, total refunds reduce the gas cost, but with limits (some refunds are capped).</li>
</ul>
<hr />
<h2 id="peek-under-the-hood-gas-struct-and-its-methods"><a class="header" href="#peek-under-the-hood-gas-struct-and-its-methods">Peek Under the Hood: Gas Struct and Its Methods</a></h2>
<p>The heart of gas management is the <code>Gas</code> struct (in <code>crates/interpreter/src/gas.rs</code>).</p>
<p>Here’s a simplified look:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
pub struct Gas {
    limit: u64,
    remaining: u64,
    refunded: i64,
}

impl Gas {
    // Create new Gas tracker with limit and remaining gas set to limit
    pub fn new(limit: u64) -&gt; Self {
        Self {
            limit,
            remaining: limit,
            refunded: 0,
        }
    }

    // Record spending gas
    // Returns false if not enough gas remains
    pub fn record_cost(&amp;mut self, cost: u64) -&gt; bool {
        if let Some(new_remaining) = self.remaining.checked_sub(cost) {
            self.remaining = new_remaining;
            true
        } else {
            false
        }
    }

    // Record a gas refund (can be negative sometimes)
    pub fn record_refund(&amp;mut self, refund: i64) {
        self.refunded += refund;
    }

    // Calculate gas spent minus refunded (refund capped internally)
    pub fn spent_sub_refunded(&amp;self) -&gt; u64 {
        let spent = self.limit.saturating_sub(self.remaining);
        spent.saturating_sub(self.refunded as u64)
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Meaning:</strong></p>
<ul>
<li><code>limit</code>: Total gas allowed.</li>
<li><code>remaining</code>: Gas left to spend.</li>
<li><code>refunded</code>: Gas to give back after execution.</li>
<li>The <code>record_cost</code> function tries to spend gas and returns if it succeeded or not.</li>
<li>Refunds accumulate during execution and adjust net gas spent.</li>
</ul>
</blockquote>
<hr />
<h2 id="memory-gas-tracking"><a class="header" href="#memory-gas-tracking">Memory Gas Tracking</a></h2>
<p>EVM memory expansion also costs gas. This is handled inside the <code>Gas</code> struct with a helper called <code>MemoryGas</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MemoryGas {
    words_num: usize,
    expansion_cost: u64,
}

impl MemoryGas {
    pub fn new() -&gt; Self {
        Self {
            words_num: 0,
            expansion_cost: 0,
        }
    }

    /// Records an expansion in memory length (number of 32-byte words)
    /// Returns additional gas cost of the expansion, if any
    pub fn record_new_len(&amp;mut self, new_num: usize) -&gt; Option&lt;u64&gt; {
        if new_num &lt;= self.words_num {
            None // No expansion, no added cost
        } else {
            self.words_num = new_num;
            // Calculate new expansion cost (simplified)
            let new_cost = new_num as u64 * 3 + (new_num as u64).pow(2) / 512;
            let cost_diff = new_cost.saturating_sub(self.expansion_cost);
            self.expansion_cost = new_cost;
            Some(cost_diff)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>Gas</code> struct calls <code>record_new_len</code> when memory grows and charges the added cost.</p>
<hr />
<h2 id="how-gas-management-helps-with-errors"><a class="header" href="#how-gas-management-helps-with-errors">How Gas Management Helps with Errors</a></h2>
<p>If gas runs out:</p>
<ul>
<li><code>record_cost</code> returns <code>false</code>.</li>
<li>The system knows that an <strong>OutOfGas error</strong> occurred.</li>
<li>Execution halts and the transaction reverts.</li>
<li>This prevents overspending or denial-of-service abuse.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if !gas.record_cost(opcode_gas_cost) {
    return Err("OutOfGas");
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>Why Gas Management is vital:</strong><br />
It tracks gas usage, refunds, and prevents overspending during EVM execution.</p>
</li>
<li>
<p><strong>How gas is tracked:</strong><br />
Gas limit, gas remaining, and refunds make up the gas state.</p>
</li>
<li>
<p><strong>Memory expansion costs:</strong><br />
Gas management also tracks memory growth costs.</p>
</li>
<li>
<p><strong>Basic usage:</strong><br />
Creating a Gas struct, spending gas, recording refunds, and checking for out-of-gas errors.</p>
</li>
<li>
<p><strong>What happens inside:</strong><br />
The gas tracker updates gas remaining, calculates net gas spent, and reports failures if gas runs out.</p>
</li>
<li>
<p><strong>How it integrates with EVM:</strong><br />
The EVM calls <code>Gas::record_cost</code> every time an instruction needs gas, ensuring execution stays within the gas limit.</p>
</li>
</ul>
<hr />
<p>Next, we will dive into how the EVM handles <strong>Bytecode &amp; Opcodes</strong> — the actual code the EVM runs, instruction by instruction. Explore <a href="Revm/05_bytecode___opcodes_.html">Chapter 5: Bytecode &amp; Opcodes</a> to continue your journey!</p>
<hr />
<p>Thank you for learning about gas management! This understanding is key to grasping how Ethereum charges for computation and resources. Keep going—you’re making great progress!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-bytecode--opcodes"><a class="header" href="#chapter-5-bytecode--opcodes">Chapter 5: Bytecode &amp; Opcodes</a></h1>
<p>Welcome back! In the previous chapter, <a href="Revm/04_gas_management_.html">Chapter 4: Gas Management</a>, we learned how the EVM tracks and manages gas — the fuel that powers Ethereum smart contracts. Now, it's time to explore the <strong>actual code the EVM runs</strong>: the <strong>Bytecode</strong> and its building blocks, the <strong>Opcodes</strong>.</p>
<hr />
<h2 id="why-is-bytecode--opcodes-important"><a class="header" href="#why-is-bytecode--opcodes-important">Why is Bytecode &amp; Opcodes Important?</a></h2>
<p>Imagine you want to bake a cake, but all you have is a recipe written in a secret code. To bake the cake, you must first understand that code: what each instruction means and how it tells you to mix, bake, and serve.</p>
<p>In Ethereum, <strong>smart contracts are compiled into low-level instructions</strong> called <strong>bytecode</strong>, which the Ethereum Virtual Machine (EVM) executes. This bytecode is a sequence of <strong>opcodes</strong> — think of them as the cooking steps from the recipe.</p>
<p>The <code>revm</code> project's Bytecode &amp; Opcodes abstraction manages:</p>
<ul>
<li>How this bytecode is represented.</li>
<li>How EVM instructions (opcodes) are defined and classified.</li>
<li>Different formats of bytecode Ethereum supports.</li>
<li>Analyzing the bytecode to prepare it for execution (like verifying jump locations).</li>
<li>Validating bytecode correctness.</li>
</ul>
<p>This layer is, essentially, the <strong>instruction set architecture</strong> and <strong>program loader</strong> for the EVM.</p>
<hr />
<h2 id="use-case-running-a-simple-smart-contract-bytecode"><a class="header" href="#use-case-running-a-simple-smart-contract-bytecode">Use Case: Running a Simple Smart Contract Bytecode</a></h2>
<p>Suppose you have a simple smart contract compiled into bytecode, for example:</p>
<pre><code class="language-text">0x60 0x01  // PUSH1 0x01  (push the number 1 to the stack)
0x60 0x02  // PUSH1 0x02  (push the number 2 to the stack)
0x01       // ADD         (add the two numbers on the stack)
0x00       // STOP        (halt execution)
</code></pre>
<p>To prepare the EVM interpreter to run this, we need to:</p>
<ol>
<li>Represent this bytecode in a form <code>revm</code> understands.</li>
<li>Know what each opcode means (PUSH1, ADD, STOP).</li>
<li>Analyze it so jumps and other features work correctly.</li>
<li>Validate it to ensure it’s safe to run.</li>
</ol>
<p>This chapter will show you how to do all that!</p>
<hr />
<h2 id="breaking-down-the-concepts-bytecode--opcodes"><a class="header" href="#breaking-down-the-concepts-bytecode--opcodes">Breaking Down the Concepts: Bytecode &amp; Opcodes</a></h2>
<p>Let's explain the key ideas behind this abstraction.</p>
<h3 id="1-bytecode"><a class="header" href="#1-bytecode">1. Bytecode</a></h3>
<p>A <strong>bytecode</strong> is a sequence of bytes that the EVM executes. Each byte corresponds to an <strong>opcode</strong>—an instruction for the EVM, optionally followed by immediate data bytes. For example, the <code>PUSH1</code> opcode is followed by 1 byte that says what to push onto the stack.</p>
<p>Ethereum supports different <strong>bytecode formats</strong>:</p>
<ul>
<li>
<p><strong>Legacy Bytecode</strong>: The original simple sequence of opcodes and immediate data.</p>
</li>
<li>
<p><strong>EOF (Ethereum Object Format)</strong>: A newer, modular bytecode format introduced for better tooling and efficiency.</p>
</li>
<li>
<p><strong>EIP-7702 Delegated Bytecode</strong>: A format for delegating code execution to other addresses.</p>
</li>
</ul>
<p><code>revm</code> supports all these formats as variants of a <code>Bytecode</code> type.</p>
<h3 id="2-opcodes"><a class="header" href="#2-opcodes">2. Opcodes</a></h3>
<p><strong>Opcodes</strong> (operation codes) are the actual EVM instructions, like <code>ADD</code> for addition, <code>PUSH1</code> for pushing a byte, <code>JUMP</code> for jumping to a location, and many more.</p>
<p>Each opcode has:</p>
<ul>
<li>An <strong>opcode byte value</strong> (e.g., <code>0x01</code> for <code>ADD</code>, <code>0x60</code> for <code>PUSH1</code>).</li>
<li><strong>Stack input and output counts</strong> (how many items it takes and puts on the stack).</li>
<li>An optional <strong>immediate data size</strong> (for <code>PUSH</code> instructions).</li>
<li>Flags like whether it <strong>terminates execution</strong> (<code>STOP</code>, <code>RETURN</code>) or is a <strong>jump destination</strong>.</li>
</ul>
<p>Opcodes are constants in the code and all known opcodes are listed with their properties.</p>
<hr />
<h2 id="how-to-represent-and-analyze-bytecode-in-revm"><a class="header" href="#how-to-represent-and-analyze-bytecode-in-revm">How to Represent and Analyze Bytecode in <code>revm</code></a></h2>
<p>Let's walk through a simple example step-by-step.</p>
<h3 id="step-1-define-your-bytecode-bytes"><a class="header" href="#step-1-define-your-bytecode-bytes">Step 1: Define Your Bytecode Bytes</a></h3>
<p>Here's the simple bytecode we introduced:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use primitives::Bytes;

let raw_bytecode: Bytes = Bytes::from_static(&amp;[
    0x60, 0x01, // PUSH1 1
    0x60, 0x02, // PUSH1 2
    0x01,       // ADD
    0x00,       // STOP
]);
<span class="boring">}</span></code></pre></pre>
<p><em>We create a byte slice representing our instructions.</em></p>
<h3 id="step-2-create-bytecode-from-raw-bytes"><a class="header" href="#step-2-create-bytecode-from-raw-bytes">Step 2: Create <code>Bytecode</code> from Raw Bytes</a></h3>
<p>Use the <code>Bytecode</code> enum to wrap this raw bytecode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::bytecode::Bytecode;

// Convert raw bytes to Bytecode (legacy analyzed)
let bytecode = Bytecode::new_legacy(raw_bytecode);
<span class="boring">}</span></code></pre></pre>
<p>This creates an analyzed bytecode variant by:</p>
<ul>
<li>Parsing the bytes.</li>
<li>Building a <strong>jump table</strong> (a helper that marks valid jump destinations).</li>
<li>Padding the bytecode if necessary (EVM requires the code to end properly).</li>
</ul>
<h3 id="step-3-inspect-the-bytecode-and-jump-table"><a class="header" href="#step-3-inspect-the-bytecode-and-jump-table">Step 3: Inspect the Bytecode and Jump Table</a></h3>
<p>Let's look at the actual bytes and jump destinations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!("Bytecode length: {}", bytecode.len());
println!("Bytecode bytes: {:?}", bytecode.bytecode());

if let Some(jump_table) = bytecode.legacy_jump_table() {
    println!("Jump destinations:");
    for (idx, is_jumpdest) in jump_table.iter().enumerate() {
        if *is_jumpdest {
            println!(" - Byte offset: {}", idx);
        }
    }
} else {
    println!("No jump table available");
}
<span class="boring">}</span></code></pre></pre>
<p><em>This will print the byte offsets that are valid jump destinations, which helps ensure <code>JUMP</code> instructions go to allowed places.</em></p>
<hr />
<h2 id="what-happens-internally-when-creating-bytecode"><a class="header" href="#what-happens-internally-when-creating-bytecode">What Happens Internally When Creating Bytecode?</a></h2>
<p>Let's visualize the process of taking raw bytes and analyzing for execution:</p>
<pre class="mermaid">sequenceDiagram
    participant User as User/Caller
    participant Bytecode as Bytecode Layer
    participant Analyzer as Jump Table Analyzer
    participant EVM as EVM Interpreter

    User-&gt;&gt;Bytecode: Provide raw bytecode bytes
    Bytecode-&gt;&gt;Analyzer: Analyze bytecode (find jump destinations)
    Analyzer--&gt;&gt;Bytecode: Return jump table and padded bytes
    Bytecode-&gt;&gt;User: Return analyzed Bytecode structure
    User-&gt;&gt;EVM: Use Bytecode for EVM execution
</pre>
<h3 id="explanation-3"><a class="header" href="#explanation-3">Explanation:</a></h3>
<ul>
<li><strong>User</strong> supplies the raw bytecode.</li>
<li>The Bytecode layer analyzes it, marking jump destinations so jumps don't land in invalid spots.</li>
<li>If needed, the bytecode is padded to ensure proper termination.</li>
<li>The analyzed bytecode is then ready to be run by the EVM.</li>
</ul>
<hr />
<h2 id="peeking-under-the-hood-bytecode-implementation"><a class="header" href="#peeking-under-the-hood-bytecode-implementation">Peeking Under the Hood: Bytecode Implementation</a></h2>
<h3 id="the-bytecode-enum"><a class="header" href="#the-bytecode-enum">The <code>Bytecode</code> Enum</a></h3>
<p>Located in <code>crates/bytecode/src/bytecode.rs</code>, the <code>Bytecode</code> enum represents different bytecode formats:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Bytecode {
    LegacyAnalyzed(LegacyAnalyzedBytecode), // Classic bytecode w/ jump table
    Eof(Arc&lt;Eof&gt;),                          // New EOF bytecode format
    Eip7702(Eip7702Bytecode),               // Delegated bytecode from EIP-7702
}
<span class="boring">}</span></code></pre></pre>
<h3 id="legacyanalyzedbytecode"><a class="header" href="#legacyanalyzedbytecode">LegacyAnalyzedBytecode</a></h3>
<p>This variant contains analyzed legacy bytecode. It includes:</p>
<ul>
<li>The raw bytecode bytes.</li>
<li>The <strong>jump table</strong> — a bitmap marking valid jump destinations.</li>
</ul>
<p>This jump table is created by scanning the code and:</p>
<ul>
<li>Marking all <code>JUMPDEST</code> opcodes as valid destinations.</li>
<li>Skipping <code>PUSH</code> immediate data to avoid misinterpreting data as instructions.</li>
</ul>
<h3 id="jump-table-analysis"><a class="header" href="#jump-table-analysis">Jump Table Analysis</a></h3>
<p>This is done in the file <code>crates/bytecode/src/legacy/analysis.rs</code>.</p>
<p>A simplified snippet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn analyze_legacy(bytecode: Bytes) -&gt; (JumpTable, Bytes) {
    let mut jumps = BitVec::new(bytecode.len()); // All false initially

    let mut i = 0;
    while i &lt; bytecode.len() {
        let op = bytecode[i];
        if op == opcode::JUMPDEST {
            jumps.set(i, true); // Mark jumpdest valid
            i += 1;
        } else if op &gt;= opcode::PUSH1 &amp;&amp; op &lt;= opcode::PUSH32 {
            let push_len = (op - opcode::PUSH1 + 1) as usize;
            i += 1 + push_len;  // Skip immediate bytes
        } else {
            i += 1;             // Move to next opcode
        }
    }

    // Possibly pad if last opcode isn't STOP
    // ...

    (JumpTable(Arc::new(jumps)), bytecode)
}
<span class="boring">}</span></code></pre></pre>
<p><em>It scans every byte, marks jump destinations, and correctly skips push data.</em></p>
<hr />
<h2 id="understanding-opcodes-in-revm"><a class="header" href="#understanding-opcodes-in-revm">Understanding Opcodes in <code>revm</code></a></h2>
<h3 id="what-is-an-opcode"><a class="header" href="#what-is-an-opcode">What is an Opcode?</a></h3>
<p>An <code>Opcode</code> is a wrapper around a <code>u8</code> that represents a single EVM instruction byte.</p>
<p>You can create an opcode like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::bytecode::opcode::OpCode;

let add_opcode = OpCode::new(0x01).unwrap(); // ADD opcode
println!("Opcode name: {}", add_opcode);
println!("Inputs: {}", add_opcode.inputs());
println!("Outputs: {}", add_opcode.outputs());
println!("Is jump: {}", add_opcode.is_jump());
<span class="boring">}</span></code></pre></pre>
<p><strong>Output explanation:</strong></p>
<ul>
<li>Opcode name: <code>ADD</code></li>
<li>Inputs: <code>2</code> (needs 2 items from the stack)</li>
<li>Outputs: <code>1</code> (produces 1 item on the stack)</li>
<li>Is jump: <code>false</code></li>
</ul>
<h3 id="opcode-properties"><a class="header" href="#opcode-properties">Opcode Properties</a></h3>
<p>Each opcode knows:</p>
<ul>
<li>How many stack items it consumes (<code>inputs()</code>).</li>
<li>How many stack items it produces (<code>outputs()</code>).</li>
<li>If it is a jump or jump destination.</li>
<li>How many immediate bytes it has (e.g., <code>PUSH1</code> has 1 immediate byte).</li>
</ul>
<hr />
<h2 id="how-are-opcodes-organized"><a class="header" href="#how-are-opcodes-organized">How Are Opcodes Organized?</a></h2>
<p>All opcode constants and their metadata are generated in a macro in <code>crates/bytecode/src/opcode.rs</code>. Here’s a tiny snippet for illustration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const ADD: u8 = 0x01;
pub const PUSH1: u8 = 0x60;
pub const STOP: u8 = 0x00;

// Create Opcode structs for convenience
impl OpCode {
    pub const ADD: Self = Self(0x01);
    pub const PUSH1: Self = Self(0x60);
    pub const STOP: Self = Self(0x00);
}
<span class="boring">}</span></code></pre></pre>
<p>Each opcode comes with <code>OpCodeInfo</code> describing its behavior (inputs, outputs, whether it terminates).</p>
<hr />
<h2 id="summary-and-whats-next"><a class="header" href="#summary-and-whats-next">Summary and What's Next?</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What is bytecode and opcode?</strong><br />
Bytecode is the raw instruction data for the EVM, composed of opcodes which represent operations like <code>ADD</code>, <code>PUSH1</code>, and <code>STOP</code>.</p>
</li>
<li>
<p><strong>Different bytecode formats:</strong><br />
Legacy (classic), EOF (new modular), and EIP-7702 (delegated bytecode) are supported.</p>
</li>
<li>
<p><strong>How bytecode is analyzed:</strong><br />
The jump table is computed to mark valid jump destinations for safe jumps.</p>
</li>
<li>
<p><strong>What information each opcode holds:</strong><br />
Their opcode byte, stack inputs/outputs, immediate data size, and execution flags.</p>
</li>
<li>
<p><strong>How to create and inspect bytecode and opcodes in <code>revm</code>.</strong></p>
</li>
</ul>
<p>Now that you understand the fundamental building blocks of contracts' code, the next step is to explore <strong>Precompiles</strong> — special built-in contracts that <code>revm</code> supports for common operations. Check out <a href="Revm/06_precompiles_.html">Chapter 6: Precompiles</a> to continue!</p>
<hr />
<p>Thank you for following along! Bytecode and opcodes are the instruction language of Ethereum contracts, and mastering them is a big step toward understanding how smart contracts really work inside the EVM. Keep up the great progress!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-precompiles"><a class="header" href="#chapter-6-precompiles">Chapter 6: Precompiles</a></h1>
<p>Welcome back! In the previous chapter, <a href="Revm/05_bytecode___opcodes_.html">Chapter 5: Bytecode &amp; Opcodes</a>, we learned about the raw code that the EVM executes: smart contract bytecode and the individual opcodes that make up programs. Now, let's explore a very special feature of the Ethereum Virtual Machine called <strong>Precompiles</strong>.</p>
<hr />
<h2 id="what-are-precompiles-and-why-do-they-matter"><a class="header" href="#what-are-precompiles-and-why-do-they-matter">What are Precompiles and Why Do They Matter?</a></h2>
<p>Imagine you're baking a fancy cake. Some steps might be really complicated — say, decorating with delicate sugar flowers. Instead of doing it by hand each time, you get a special tool that does this tricky part super fast and perfectly.</p>
<p>In the world of Ethereum, <strong>Precompiles are like those special tools</strong>. They are built-in, highly optimized “mini-programs” that the EVM can run by just calling certain special addresses — instead of running complex smart contract code instruction by instruction.</p>
<p>Why is this useful?</p>
<ul>
<li>Some cryptographic or mathematical operations are very complex and slow if done purely in EVM bytecode.</li>
<li>Precompiles offer <strong>native, efficient implementations</strong> of these operations.</li>
<li>This saves gas, execution time, and memory.</li>
</ul>
<p>For example, operations on elliptic curves (used for cryptography), or special hash functions, are exposed through precompiles.</p>
<hr />
<h2 id="central-use-case-verify-a-cryptographic-signature-efficiently"><a class="header" href="#central-use-case-verify-a-cryptographic-signature-efficiently">Central Use Case: Verify a Cryptographic Signature Efficiently</a></h2>
<p>Suppose you want your smart contract to <strong>verify a signature</strong> using the secp256k1 elliptic curve (the same one Bitcoin uses).</p>
<ul>
<li>You <em>could</em> write the signature verification code fully in Solidity and compile it.</li>
<li>However, this would be very expensive and slow in gas since elliptic curve math is complex.</li>
<li>Instead, Ethereum provides a <strong>precompile contract</strong> at a fixed address that does this efficiently.</li>
<li>Your contract calls that address with the right input, and gets the verification result instantly.</li>
</ul>
<p>This is the power of precompiles — complex cryptography and other functions can be done easily and cheaply.</p>
<hr />
<h2 id="key-concepts-in-precompiles"><a class="header" href="#key-concepts-in-precompiles">Key Concepts in Precompiles</a></h2>
<p>Let’s understand how precompiles work in revm.</p>
<h3 id="1-precompile-contracts"><a class="header" href="#1-precompile-contracts">1. <strong>Precompile Contracts</strong></a></h3>
<ul>
<li>Special contracts at fixed addresses (like <code>0x01</code>, <code>0x06</code>, etc.).</li>
<li>They don’t have bytecode; instead, they run native Rust code inside revm.</li>
<li>Examples include: <code>ECRECOVER</code> (secp256k1 signature recovery), <code>BN128_ADD</code> (elliptic curve addition), <code>BLAKE2</code> hash, and others.</li>
</ul>
<h3 id="2-precompile-address"><a class="header" href="#2-precompile-address">2. <strong>Precompile Address</strong></a></h3>
<ul>
<li>Each precompile lives at a <strong>known, unique address</strong>.</li>
<li>To call a precompile, the EVM executes a call instruction to that address.</li>
<li>revm recognizes these addresses and runs the special native code instead of bytecode.</li>
</ul>
<h3 id="3-precompile-input-and-output"><a class="header" href="#3-precompile-input-and-output">3. <strong>Precompile Input and Output</strong></a></h3>
<ul>
<li>The input is a byte slice (<code>&amp;[u8]</code>) representing parameters.</li>
<li>The output is a slice of bytes representing the result.</li>
<li>The exact format of input/output depends on the precompile’s specification.</li>
<li>revm precompiles handle input parsing, computation, gas charging, and output formatting.</li>
</ul>
<h3 id="4-gas-cost"><a class="header" href="#4-gas-cost">4. <strong>Gas Cost</strong></a></h3>
<ul>
<li>Each precompile requires some amount of gas to run.</li>
<li>revm enforces gas limits — if insufficient gas, it returns an OutOfGas error.</li>
<li>Gas cost can depend on input size or complexity of the operation.</li>
</ul>
<hr />
<h2 id="how-to-use-precompiles-in-revm"><a class="header" href="#how-to-use-precompiles-in-revm">How to Use Precompiles in revm?</a></h2>
<p>Here’s a very simple example of <em>calling</em> a precompile in revm. Imagine we want to run the <code>ecrecover</code> precompile (at address <code>0x01</code>) with some input.</p>
<pre><pre class="playground"><code class="language-rust">use revm::precompile::secp256k1::ECRECOVER;
use primitives::{Address, Bytes};

fn main() {
    // The address of the ecrecover precompile contract
    let precompile_address: Address = revm::precompile::u64_to_address(1);

    // Example input (usually message hash + signature + recovery id) as bytes
    let input: Bytes = Bytes::from_static(&amp;[
        // 32 bytes message hash (simplified example)
        0; 32,
        // 64 bytes signature (r and s components, simplified zeroes)
        0; 64,
        // 1 byte recovery id (27 or 28)
        27,
    ]);

    // Example gas limit
    let gas_limit: u64 = 10_000;

    // Run the precompile function
    match ECRECOVER.precompile()(&amp;input, gas_limit) {
        Ok(output) =&gt; {
            println!("Precompile succeeded!");
            println!("Gas used: {}", output.gas_used);
            println!("Output bytes: {:?}", output.bytes);
        }
        Err(e) =&gt; {
            println!("Precompile failed with error: {}", e);
        }
    }
}</code></pre></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>We specify the input bytes to the function.</li>
<li>We pick a gas limit for this call.</li>
<li>We call the precompile function, which executes the native code.</li>
<li>On success, we get gas used and output bytes.</li>
<li>On failure, for example due to out-of-gas or bad input, we get an error.</li>
</ul>
<hr />
<h2 id="what-happens-inside-a-precompile-call-step-by-step"><a class="header" href="#what-happens-inside-a-precompile-call-step-by-step">What Happens Inside a Precompile Call? (Step-by-Step)</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Caller as Contract Caller
    participant EVM as EVM Interpreter
    participant PRE as Precompile Module
    participant Gas as Gas Tracker

    Caller-&gt;&gt;EVM: Calls precompile address with input data
    EVM-&gt;&gt;PRE: Recognizes address as precompile, forwards input and gas limit
    PRE-&gt;&gt;Gas: Checks gas availability for operation
    alt Gas sufficient
        PRE-&gt;&gt;PRE: Executes native function (e.g. elliptic curve math)
        PRE-&gt;&gt;Gas: Charges gas used
        PRE--&gt;&gt;EVM: Return computation output and gas used
    else Out of gas
        PRE--&gt;&gt;EVM: Return OutOfGas error
    end
    EVM--&gt;&gt;Caller: Return result bytes or error
</pre>
<hr />
<h2 id="internal-implementation-details-in-revm"><a class="header" href="#internal-implementation-details-in-revm">Internal Implementation Details in revm</a></h2>
<h3 id="where-are-precompiles-defined"><a class="header" href="#where-are-precompiles-defined">Where Are Precompiles Defined?</a></h3>
<ul>
<li>Located in the crate <code>crates/precompile/src</code></li>
<li>Each precompile typically lives in its own module, like:
<ul>
<li><code>bn128.rs</code> (alt_bn128 elliptic curve operations)</li>
<li><code>secp256k1.rs</code> (<code>ecrecover</code>)</li>
<li><code>bls12_381.rs</code> (BLS signatures)</li>
<li><code>kzg_point_evaluation.rs</code> (KZG polynomial commitments)</li>
<li><code>modexp.rs</code> (big modular exponentiation)</li>
<li><code>blake2.rs</code> (blake2 hash function)</li>
<li>and more.</li>
</ul>
</li>
</ul>
<h3 id="how-are-precompiles-registered"><a class="header" href="#how-are-precompiles-registered">How Are Precompiles Registered?</a></h3>
<ul>
<li>The <code>Precompiles</code> struct stores a <strong>map of address → precompile function</strong>.</li>
<li>Different Ethereum hardforks enable different sets of precompiles (e.g., Byzantium adds bn128).</li>
<li>You can get the set of precompiles for a spec like <code>Precompiles::latest()</code>.</li>
</ul>
<h3 id="precompile-function-signature"><a class="header" href="#precompile-function-signature">Precompile Function Signature</a></h3>
<p>Each precompile exposes a function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn precompile(input: &amp;Bytes, gas_limit: u64) -&gt; Result&lt;PrecompileOutput, PrecompileError&gt;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Takes input data and the gas limit.</li>
<li>Returns either a successful output (gas used + output bytes) or an error.</li>
</ul>
<h3 id="example-simple-ecrecover-implementation-snippet-from-secp256k1rs"><a class="header" href="#example-simple-ecrecover-implementation-snippet-from-secp256k1rs">Example: Simple <code>ecrecover</code> Implementation Snippet (from <code>secp256k1.rs</code>)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn ec_recover_run(input: &amp;Bytes, gas_limit: u64) -&gt; PrecompileResult {
    const BASE_GAS: u64 = 3_000;

    if BASE_GAS &gt; gas_limit {
        return Err(PrecompileError::OutOfGas);
    }

    let input = right_pad::&lt;128&gt;(input);

    // Validate the 'v' parameter and parse input...

    // Do the actual ecrecover logic (using a crypto library)...

    Ok(PrecompileOutput::new(BASE_GAS, recovered_address_bytes))
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>First, it checks if gas limit is enough.</li>
<li>Pads input to expected length.</li>
<li>Parses input parameters.</li>
<li>Calls underlying cryptographic verification.</li>
<li>Returns fixed gas used and output bytes.</li>
</ul>
<hr />
<h2 id="example-the-bn128-addition-precompile"><a class="header" href="#example-the-bn128-addition-precompile">Example: The BN128 Addition Precompile</a></h2>
<p>This precompile takes two elliptic curve points as input and outputs their sum.</p>
<p>Minimal flow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn run_add(input: &amp;[u8], gas_cost: u64, gas_limit: u64) -&gt; PrecompileResult {
    if gas_cost &gt; gas_limit {
        return Err(PrecompileError::OutOfGas);
    }

    // Pad or truncate input to expected length
    let input = right_pad::&lt;ADD_INPUT_LEN&gt;(input);

    // Deserialize two points from input bytes
    let p1 = read_g1_point(&amp;input[..G1_LEN])?;
    let p2 = read_g1_point(&amp;input[G1_LEN..])?;

    // Compute sum of points
    let result = g1_point_add(p1, p2);

    // Encode result back to bytes
    let output = encode_g1_point(result);

    Ok(PrecompileOutput::new(gas_cost, output.into()))
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Inputs are two fixed-length byte arrays.</li>
<li>The function checks gas, deserializes, performs addition, and returns results.</li>
<li>Error handling is done with proper <code>PrecompileError</code> variants.</li>
</ul>
<hr />
<h2 id="summary-what-did-we-learn"><a class="header" href="#summary-what-did-we-learn">Summary: What Did We Learn?</a></h2>
<ul>
<li><strong>Precompiles are special built-in contracts that provide native implementations of complex operations</strong> like cryptographic functions or big integer math.</li>
<li>They run much faster and cheaper than equivalent EVM bytecode.</li>
<li>revm exposes them as functions callable by the EVM at fixed addresses.</li>
<li>Precompiles handle input parsing, gas charging, computation, and output formatting.</li>
<li>Different Ethereum upgrades add or change precompiles, which revm tracks via the <code>Precompiles</code> struct.</li>
<li>Using precompiles is as simple as calling their address during contract execution.</li>
</ul>
<hr />
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next?</a></h2>
<p>You have now seen how revm handles special native contracts that speed up complex tasks. Next, you will learn how the <strong>Interpreter</strong> actually runs smart contract bytecode step by step, using all the tools we've covered:</p>
<p>Check out <a href="Revm/07_interpreter_.html">Chapter 7: Interpreter</a> to dive in!</p>
<hr />
<p>Thank you for your attention! Precompiles might seem magical at first, but understanding their purpose and implementation gives you powerful insight into Ethereum's efficiency tricks. Keep exploring!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-interpreter"><a class="header" href="#chapter-7-interpreter">Chapter 7: Interpreter</a></h1>
<p>Welcome back! In the previous chapter, we explored <a href="Revm/06_precompiles_.html">Precompiles</a> — those special native contracts that do heavy lifting like cryptography outside of the regular EVM bytecode. Now, let's dive into the heart of the <code>revm</code> project: the <strong>Interpreter</strong>.</p>
<hr />
<h2 id="what-is-the-interpreter-and-why-do-we-need-it"><a class="header" href="#what-is-the-interpreter-and-why-do-we-need-it">What is the Interpreter and Why Do We Need It?</a></h2>
<p>Think of the <strong>Interpreter</strong> as the <strong>engine</strong> or the <strong>virtual CPU</strong> of the Ethereum Virtual Machine (EVM). Its job is to:</p>
<ul>
<li><strong>Read</strong> smart contract bytecode instruction-by-instruction.</li>
<li><strong>Execute</strong> each instruction in the correct order.</li>
<li><strong>Manage</strong> the EVM stack, memory, and program counter (the pointer to the current instruction).</li>
<li>Keep track of <strong>gas</strong> usage for each operation.</li>
<li>Handle operations such as arithmetic, data loading, contract calls, and control flow (jumps, conditionals).</li>
<li>Manage interactions with the <strong>host</strong> (the blockchain environment).</li>
<li>Control when execution stops or returns results/errors.</li>
</ul>
<p>Put simply: <strong>the Interpreter makes your smart contract code come to life!</strong></p>
<hr />
<h2 id="central-use-case-running-a-simple-smart-contract-function"><a class="header" href="#central-use-case-running-a-simple-smart-contract-function">Central Use Case: Running a Simple Smart Contract Function</a></h2>
<p>Imagine you deployed a smart contract with bytecode that just:</p>
<ol>
<li>Pushes the number 2 onto the stack.</li>
<li>Pushes the number 3 onto the stack.</li>
<li>Adds these two numbers.</li>
<li>Stops execution and returns the result.</li>
</ol>
<p>The Interpreter reads these instructions one by one and executes them:</p>
<ul>
<li>Stack after first instruction: [2]</li>
<li>Stack after second instruction: [2, 3]</li>
<li>After <code>ADD</code>: pops 3 and 2, pushes 5 → stack is now [5]</li>
<li><code>STOP</code> ends execution, output is 5</li>
</ul>
<p>The Interpreter handles all of this automatically by interpreting the bytecode.</p>
<hr />
<h2 id="breaking-down-the-interpreter-key-concepts"><a class="header" href="#breaking-down-the-interpreter-key-concepts">Breaking Down the Interpreter: Key Concepts</a></h2>
<p>Let's explore the core parts the Interpreter manages:</p>
<h3 id="1-bytecode--program-counter"><a class="header" href="#1-bytecode--program-counter">1. <strong>Bytecode &amp; Program Counter</strong></a></h3>
<ul>
<li>The Interpreter holds the smart contract's bytecode.</li>
<li>A <strong>program counter (PC)</strong> points to the current instruction's byte offset.</li>
<li>After executing each instruction, PC moves forward (or jumps elsewhere for control flow).</li>
</ul>
<h3 id="2-stack"><a class="header" href="#2-stack">2. <strong>Stack</strong></a></h3>
<ul>
<li>EVM uses a <strong>stack machine</strong>: operations push and pop values on an internal stack.</li>
<li>Stack size is limited (max 1024 entries).</li>
<li>Instructions consume (pop) some values and produce (push) new ones.</li>
</ul>
<h3 id="3-memory"><a class="header" href="#3-memory">3. <strong>Memory</strong></a></h3>
<ul>
<li>Temporary memory for contracts during execution.</li>
<li>Supports reading and writing 32-byte words.</li>
<li>Memory can grow dynamically but costs gas (tracked by Gas).</li>
</ul>
<h3 id="4-gas-management"><a class="header" href="#4-gas-management">4. <strong>Gas Management</strong></a></h3>
<ul>
<li>Every instruction consumes gas.</li>
<li>Interpreter consults gas tracker to check if there's enough gas.</li>
<li>Stops execution if gas runs out.</li>
</ul>
<h3 id="5-host-interaction"><a class="header" href="#5-host-interaction">5. <strong>Host Interaction</strong></a></h3>
<ul>
<li>Some instructions (like <code>SLOAD</code> or <code>CALL</code>) need to interact with the blockchain state.</li>
<li>Interpreter calls the <strong>Host Interface</strong> to perform these operations safely.</li>
</ul>
<h3 id="6-instruction-table"><a class="header" href="#6-instruction-table">6. <strong>Instruction Table</strong></a></h3>
<ul>
<li>Interpreter uses a lookup table mapping opcode bytes to functions.</li>
<li>Each instruction function implements the behavior of one opcode.</li>
</ul>
<h3 id="7-control-flags--execution-flow"><a class="header" href="#7-control-flags--execution-flow">7. <strong>Control Flags &amp; Execution Flow</strong></a></h3>
<ul>
<li>Handles stopping, reverting, errors.</li>
<li>Can manage subroutine calls (<code>CALL</code>, <code>CREATE</code>).</li>
</ul>
<hr />
<h2 id="how-to-use-the-interpreter-a-simple-example"><a class="header" href="#how-to-use-the-interpreter-a-simple-example">How to Use the Interpreter: A Simple Example</a></h2>
<p>Here’s a beginner-friendly Rust snippet that creates an interpreter and runs simple bytecode.</p>
<pre><pre class="playground"><code class="language-rust">use revm::interpreter::{Interpreter, instruction_table};
use bytecode::Bytecode;
use primitives::{Bytes, Address, U256};

fn main() {
    // Simple bytecode: PUSH1 2, PUSH1 3, ADD, STOP
    let code: Bytes = Bytes::from_static(&amp;[0x60, 0x02, 0x60, 0x03, 0x01, 0x00]);

    // Wrap bytes into Bytecode (legacy format)
    let bytecode = Bytecode::new_legacy(code);

    // Initialize the interpreter
    let mut interpreter = Interpreter::new(
        revm::interpreter::SharedMemory::new(), // memory buffer
        revm::interpreter::ExtBytecode::new(bytecode),
        revm::interpreter::InputsImpl {
            target_address: Address::ZERO,
            caller_address: Address::ZERO,
            input: Bytes::new(),
            call_value: U256::ZERO,
        },
        false,          // is_static
        false,          // is_eof_init
        revm::primitives::hardfork::SpecId::LATEST,
        1_000_000,      // gas limit
    );

    // Prepare instruction table
    let instr_table = instruction_table::&lt;revm::interpreter::EthInterpreter, _&gt;();

    // Run interpreter until halt
    let result = interpreter.run_plain(&amp;instr_table, &amp;mut revm::interpreter::DummyHost);

    // Output gas used and the top stack value (5 expected)
    println!("Gas left: {}", result.gas.remaining());
    println!("Execution result success: {}", result.is_ok());
    // Note: output bytes are empty here since no RETURN opcode
}</code></pre></pre>
<p><strong>What happens here?</strong></p>
<ul>
<li>We provide some bytecode pushing <code>2</code> and <code>3</code>, adds them, and stops.</li>
<li>Create the Interpreter instance.</li>
<li>Run it with the instruction table (which has all opcode implementations).</li>
<li>Finally print gas left and execution success.</li>
</ul>
<hr />
<h2 id="what-happens-inside-the-interpreter-step-by-step"><a class="header" href="#what-happens-inside-the-interpreter-step-by-step">What Happens Inside the Interpreter? Step-by-Step</a></h2>
<p>Let's visualize what happens during execution of this bytecode:</p>
<pre class="mermaid">sequenceDiagram
    participant Int as Interpreter
    participant Host as Host Interface (dummy here)
    participant Stack as Internal Stack
    participant Mem as Memory
    participant Gas as Gas Tracker

    Int-&gt;&gt;Int: Fetch opcode at PC=0 (PUSH1)
    Int-&gt;&gt;Stack: Push 2 onto stack
    Int-&gt;&gt;Gas: Deduct gas for PUSH1
    Int-&gt;&gt;Int: PC += 2

    Int-&gt;&gt;Int: Fetch opcode at PC=2 (PUSH1)
    Int-&gt;&gt;Stack: Push 3 onto stack
    Int-&gt;&gt;Gas: Deduct gas
    Int-&gt;&gt;Int: PC += 2

    Int-&gt;&gt;Int: Fetch opcode at PC=4 (ADD)
    Int-&gt;&gt;Stack: Pop 2 and 3
    Int-&gt;&gt;Stack: Push 5
    Int-&gt;&gt;Gas: Deduct gas for ADD
    Int-&gt;&gt;Int: PC += 1

    Int-&gt;&gt;Int: Fetch opcode at PC=5 (STOP)
    Int-&gt;&gt;Int: Halt execution

    Int--&gt;&gt;Host: No host calls needed
    Int--&gt;&gt;User: Return final gas, output, status
</pre>
<h3 id="explanation-4"><a class="header" href="#explanation-4">Explanation:</a></h3>
<ul>
<li>The Interpreter reads each opcode sequentially.</li>
<li>Executes the corresponding instruction function.</li>
<li>Manages stack and gas accordingly.</li>
<li>Stops when it reads a <code>STOP</code> (or other halting instruction).</li>
</ul>
<hr />
<h2 id="diving-deeper-how-does-the-interpreter-implement-each-opcode"><a class="header" href="#diving-deeper-how-does-the-interpreter-implement-each-opcode">Diving Deeper: How Does the Interpreter Implement Each Opcode?</a></h2>
<p>The <code>revm</code> interpreter uses an <strong>instruction table</strong> — an array indexed by opcode numbers — where each entry points to the function handling that opcode.</p>
<p>Here is a small simplified example from <code>crates/interpreter/src/instructions.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Instruction&lt;W, H&gt; = for&lt;'a&gt; fn(&amp;'a mut Interpreter&lt;W&gt;, &amp;'a mut H);

// Instruction function for ADD opcode (0x01)
fn add&lt;W: InterpreterTypes, H: Host + ?Sized&gt;(
    interp: &amp;mut Interpreter&lt;W&gt;,
    _host: &amp;mut H,
) {
    // Pop two values from stack
    let a = interp.stack.pop().expect("stack underflow");
    let b = interp.stack.pop().expect("stack underflow");

    // Add and push result
    interp.stack.push(a + b);

    // Deduct gas (simplified)
    interp.control.gas_mut().record_cost(3);
}

// The instruction table filling example
let mut table = [control::unknown as Instruction&lt;W, H&gt;; 256];
table[0x01] = add;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Each instruction function receives a mutable interpreter and host.</li>
<li>Executes the opcode logic (stack ops, memory, host calls).</li>
<li>Updates gas.</li>
<li>Updates program counter implicitly by the interpreter’s run loop.</li>
</ul>
<p>This approach makes the interpreter <strong>fast and modular</strong>.</p>
<hr />
<h2 id="how-does-the-interpreter-handle-control-flow"><a class="header" href="#how-does-the-interpreter-handle-control-flow">How Does the Interpreter Handle Control Flow?</a></h2>
<p>Some instructions alter the program counter directly:</p>
<ul>
<li><code>JUMP</code> sets PC to a new location learned from stack.</li>
<li><code>JUMPI</code> conditionally jumps.</li>
<li><code>CALL</code> and <code>CREATE</code> trigger sub-interpreters for nested contract calls.</li>
</ul>
<p>Here is a very tiny look at <code>JUMP</code> instruction handler simplified:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn jump&lt;W: InterpreterTypes, H: Host + ?Sized&gt;(interp: &amp;mut Interpreter&lt;W&gt;, _host: &amp;mut H) {
    let dest = interp.stack.pop().expect("stack underflow");
    let dest_usize = dest.as_usize();

    // Check if jumpdest is valid (jump table)
    if !interp.bytecode.legacy_jump_table().map_or(false, |table| table[dest_usize]) {
        interp.control.set_next_action(
            InterpreterAction::Return {
                result: InstructionResult::InvalidJump,
                output: Bytes::new(),
                gas: interp.control.gas().clone(),
            },
            InstructionResult::InvalidJump,
        );
        return;
    }

    // Move PC to jump destination
    interp.bytecode.set_pc(dest_usize);
}
<span class="boring">}</span></code></pre></pre>
<p>This shows how the interpreter validates jump destinations and moves the PC accordingly.</p>
<hr />
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What the Interpreter is:</strong><br />
It's the virtual CPU of the EVM that reads, decodes, and executes smart contract bytecode.</p>
</li>
<li>
<p><strong>Key responsibilities:</strong><br />
Managing the stack, memory, gas, program counter, executing instructions step by step.</p>
</li>
<li>
<p><strong>Core components:</strong><br />
Bytecode with program counter, stack, memory, gas management, host interface, instruction lookup table.</p>
</li>
<li>
<p><strong>How to use it:</strong><br />
Create an interpreter instance with bytecode, then run it using the instruction table.</p>
</li>
<li>
<p><strong>Internal workings:</strong><br />
The interpreter fetches opcodes sequentially, executes their handlers, manages flow and gas, and halts on <code>STOP</code> or error.</p>
</li>
<li>
<p><strong>Control flow handled via jumps and calls with validation.</strong></p>
</li>
</ul>
<p>The Interpreter is the beating heart of <code>revm</code> that brings smart contract code execution to reality!</p>
<hr />
<p>Next up, we will explore how the EVM uses this Interpreter when managing <strong>frames and call handling</strong> — how contracts call each other and manage execution contexts. Let’s continue with <a href="Revm/08_frame___call_handling_.html">Chapter 8: Frame &amp; Call Handling</a>.</p>
<hr />
<p>Thank you for following along! You’re now equipped with a solid understanding of how the EVM executes smart contracts step-by-step using the Interpreter. Keep exploring!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8-frame--call-handling"><a class="header" href="#chapter-8-frame--call-handling">Chapter 8: Frame &amp; Call Handling</a></h1>
<p>Welcome back! In the previous chapter, <a href="Revm/07_interpreter_.html">Interpreter</a>, we learned how the EVM reads and executes smart contract bytecode step-by-step. Now, we're going one level <em>above</em> the interpreter to understand <strong>how the EVM manages multiple nested calls and contract creations during execution</strong>.</p>
<p>This chapter covers the important concept of <strong>Frames &amp; Call Handling</strong> — the way <code>revm</code> organizes execution contexts, manages nested calls, tracks local states, and returns results smoothly.</p>
<hr />
<h2 id="why-do-we-need-frames--call-handling"><a class="header" href="#why-do-we-need-frames--call-handling">Why Do We Need Frames &amp; Call Handling?</a></h2>
<p>Imagine you're watching a TV series where characters frequently call each other on the phone. Each conversation is a <strong>call</strong>. Some calls may involve another call inside them (like a conference call), and each call has its own context: who's talking, what was said before, what will happen next.</p>
<p>In the EVM:</p>
<ul>
<li>Smart contracts <em>call</em> other contracts.</li>
<li>Contracts <em>create</em> new contracts.</li>
<li>Calls can be nested many layers deep.</li>
<li>Each call has its own execution environment — stack, memory, gas limits.</li>
<li>We need to keep track of these <strong>execution contexts</strong> so that when a nested call finishes, its result comes back correctly to the original caller.</li>
<li>We must manage gas usage, state changes, and errors per call.</li>
<li>Sometimes calls revert, and we need to revert state changes only in that sub-call.</li>
</ul>
<p>This is the job of <strong>Frames &amp; Call Handling</strong>. They act like <strong>"context managers"</strong> that keep track of:</p>
<ul>
<li>The current executing contract (frame).</li>
<li>Parent and child execution frames (call stack).</li>
<li>Memory and gas per call.</li>
<li>Checkpoints for safe state reverting.</li>
<li>Propagating results back up after calls.</li>
</ul>
<hr />
<h2 id="a-central-use-case-a-contract-calls-another-contract"><a class="header" href="#a-central-use-case-a-contract-calls-another-contract">A Central Use Case: A Contract Calls Another Contract</a></h2>
<p>Suppose contract A calls contract B:</p>
<ul>
<li>Contract A starts executing (Frame A).</li>
<li>It runs an instruction <code>CALL</code> to contract B.</li>
<li>Frame B is created, executing contract B’s code with its own gas and memory.</li>
<li>Contract B finishes and returns some data.</li>
<li>Frame B ends, popping from the call stack and letting Frame A resume.</li>
<li>Contract A uses the result and continues execution.</li>
</ul>
<p>During this process, we want to:</p>
<ul>
<li>Manage separate <code>Gas</code> for contract B’s execution.</li>
<li>Track state changes in Frame B, but only commit them if B succeeds. If B reverts, revert those changes without affecting A.</li>
<li>Pass the output data of Frame B back to Frame A.</li>
</ul>
<p>How does <code>revm</code> handle this? Through a combination of <strong>frames</strong>, <strong>call stacks</strong>, and <strong>state checkpointing</strong>.</p>
<hr />
<h2 id="key-concepts-of-frame--call-handling"><a class="header" href="#key-concepts-of-frame--call-handling">Key Concepts of Frame &amp; Call Handling</a></h2>
<p>Let's break this complex idea into simple pieces:</p>
<h3 id="1-frame"><a class="header" href="#1-frame">1. <strong>Frame</strong></a></h3>
<ul>
<li>A <strong>frame</strong> is an execution context for a single call or contract creation.</li>
<li>It includes:
<ul>
<li>The contract code being run.</li>
<li>Memory and stack for this execution.</li>
<li>Gas allocated for this call.</li>
<li>State checkpoint for rollback.</li>
<li>Information about call depth.</li>
<li>Input data and values transferred.</li>
</ul>
</li>
</ul>
<h3 id="2-call-stack"><a class="header" href="#2-call-stack">2. <strong>Call Stack</strong></a></h3>
<ul>
<li>The call stack tracks <strong>all active frames</strong>, like a stack of trays in a kitchen.</li>
<li>When a new call or creation happens, a new frame is <em>pushed</em> onto the stack.</li>
<li>When the call finishes, that frame is <em>popped</em> off.</li>
<li>The stack limit prevents too deep nesting (usually max 1024 calls).</li>
</ul>
<h3 id="3-checkpointing"><a class="header" href="#3-checkpointing">3. <strong>Checkpointing</strong></a></h3>
<ul>
<li>Before starting a new call frame, revm creates a <strong>checkpoint</strong> of the blockchain state using "journaling".</li>
<li>If the call succeeds, the checkpoint is <strong>committed</strong>, making changes permanent.</li>
<li>If the call reverts, the checkpoint is <strong>reverted</strong>, undoing all changes during that call.</li>
</ul>
<h3 id="4-call-inputs-and-outputs"><a class="header" href="#4-call-inputs-and-outputs">4. <strong>Call Inputs and Outputs</strong></a></h3>
<ul>
<li>
<p><strong>Inputs</strong> include:</p>
<ul>
<li>Target address</li>
<li>Caller address</li>
<li>Input calldata</li>
<li>Gas allocated for this call</li>
<li>Transfer value (ETH)</li>
<li>Call scheme (CALL, DELEGATECALL, CREATE, etc.)</li>
</ul>
</li>
<li>
<p><strong>Outputs</strong> include:</p>
<ul>
<li>Result (success, revert, or error)</li>
<li>Gas remaining</li>
<li>Output data (return or revert data)</li>
<li>Any created address (for creations)</li>
</ul>
</li>
</ul>
<h3 id="5-frame-data-and-frame-result"><a class="header" href="#5-frame-data-and-frame-result">5. <strong>Frame Data and Frame Result</strong></a></h3>
<ul>
<li>Frames carry internal data: like return memory range (for calls) or created address (for creations).</li>
<li>When execution ends, frames produce a <strong>frame result</strong> which wraps the outputs in a uniform way.</li>
</ul>
<hr />
<h2 id="how-to-use-frames--call-handling-in-revm"><a class="header" href="#how-to-use-frames--call-handling-in-revm">How to Use Frames &amp; Call Handling in <code>revm</code></a></h2>
<p>Let's look at a beginner-friendly example simulating a simple call frame creation and running it.</p>
<h3 id="step-1-define-inputs-for-a-call"><a class="header" href="#step-1-define-inputs-for-a-call">Step 1: Define Inputs for a Call</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::interpreter::{CallInputs, CallScheme, CallValue};
use primitives::{Address, Bytes, U256};

let target_address = "0x0000000000000000000000000000000000000001".parse().unwrap();
let caller_address = "0x0000000000000000000000000000000000000002".parse().unwrap();

let call_inputs = CallInputs {
    target_address,
    caller: caller_address,
    input: Bytes::from_static(b"hello"),  // input data to the call
    value: CallValue::Transfer(U256::zero()), // no ETH transferred
    gas_limit: 1_000_000,
    scheme: CallScheme::Call,
    is_static: false,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p><em>Here we prepare all the parameters needed to make a call frame.</em></p>
<h3 id="step-2-create-a-call-frame"><a class="header" href="#step-2-create-a-call-frame">Step 2: Create a Call Frame</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::handler::EthFrame;
use revm::interpreter::SharedMemory;

let mut evm = /* create and initialize your EVM runtime with context and precompiles */;
let depth = 0;
let memory = SharedMemory::new();

let result = EthFrame::make_call_frame(&amp;mut evm, depth, memory, Box::new(call_inputs));

match result {
    Ok(revm::handler::ItemOrResult::Item(frame)) =&gt; {
        println!("Successfully created call frame at depth {}", depth);
        // You can now run the frame interpreter (see next step)
    }
    Ok(revm::handler::ItemOrResult::Result(res)) =&gt; {
        println!("Call failed immediately with result: {:?}", res.instruction_result());
    }
    Err(e) =&gt; {
        println!("Failed to create call frame: {:?}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>This attempts to create a call frame with the given inputs. If call stack depth exceeds limit or funds are insufficient, it returns error.</em></p>
<h3 id="step-3-running-the-frame"><a class="header" href="#step-3-running-the-frame">Step 3: Running the Frame</a></h3>
<p>You would then run the <code>Interpreter</code> associated with this frame, which runs contract B’s code step by step as explained in <a href="Revm/07_interpreter_.html">Chapter 7: Interpreter</a>.</p>
<p>When the frame execution is complete, you get a <code>FrameResult</code>, which you can then process to:</p>
<ul>
<li>Commit or revert the state checkpoint.</li>
<li>Return gas and output to the caller.</li>
<li>Pop the frame from the call stack.</li>
</ul>
<hr />
<h2 id="what-happens-internally-step-by-step-call-frame-flow"><a class="header" href="#what-happens-internally-step-by-step-call-frame-flow">What Happens Internally? Step-by-Step Call Frame Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Caller as Caller Frame (e.g., contract A)
    participant Handler as Frame Handler
    participant Frame as New Call Frame (e.g., contract B)
    participant Journal as Journal &amp; State Checkpoint
    participant Interpreter as Bytecode Interpreter

    Caller-&gt;&gt;Handler: Request to start new call frame with inputs
    Handler-&gt;&gt;Journal: Create state checkpoint for call frame
    Handler-&gt;&gt;Frame: Initialize frame with interpreter, inputs, depth, checkpoint
    Frame-&gt;&gt;Interpreter: Run contract bytecode with gas &amp; inputs
    Interpreter--&gt;&gt;Frame: Return execution result (success/error)
    alt Execution success
        Handler-&gt;&gt;Journal: Commit checkpoint to state
    else Execution failed or reverted
        Handler-&gt;&gt;Journal: Revert checkpoint (undo changes)
    end
    Frame--&gt;&gt;Handler: Return FrameResult (gas, output, status)
    Handler-&gt;&gt;Caller: Pass call output and gas back
</pre>
<h3 id="explanation-5"><a class="header" href="#explanation-5">Explanation:</a></h3>
<ul>
<li>Each new call creates a <strong>frame</strong> with isolated execution environment.</li>
<li>A <strong>checkpoint</strong> snapshot of state is used to manage changes safely.</li>
<li>The <code>Interpreter</code> runs the code inside the frame.</li>
<li>On success, changes are committed; on revert, all changes are undone.</li>
<li>The outcome (success/fail, gas, output data) propagates back up through the call stack.</li>
</ul>
<hr />
<h2 id="peeking-under-the-hood-how-frame-handling-is-implemented"><a class="header" href="#peeking-under-the-hood-how-frame-handling-is-implemented">Peeking Under the Hood: How Frame Handling Is Implemented</a></h2>
<h3 id="the-frame-trait--ethframe-struct"><a class="header" href="#the-frame-trait--ethframe-struct">The Frame Trait &amp; <code>EthFrame</code> Struct</a></h3>
<p>In <code>crates/handler/src/frame.rs</code>, the core <code>Frame</code> trait defines operations for frames like initializing, running, and returning results:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Frame: Sized {
    type Evm;
    type FrameInit;
    type FrameResult;
    type Error;

    fn init_first(evm: &amp;mut Self::Evm, frame_input: Self::FrameInit)
        -&gt; Result&lt;FrameOrResult&lt;Self&gt;, Self::Error&gt;;

    fn run(&amp;mut self, evm: &amp;mut Self::Evm) -&gt; Result&lt;FrameInitOrResult&lt;Self&gt;, Self::Error&gt;;

    fn return_result(&amp;mut self, evm: &amp;mut Self::Evm, result: Self::FrameResult)
        -&gt; Result&lt;(), Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>init_first</code>: creates the first frame.</li>
<li><code>run</code>: runs the frame (runs the interpreter until stop).</li>
<li><code>return_result</code>: handles returning the frame's output to the caller.</li>
</ul>
<p>The concrete implementation for Ethereum is in <code>EthFrame</code>, which holds:</p>
<ul>
<li>Frame data (<code>CallFrame</code>, <code>CreateFrame</code>, etc.)</li>
<li>Input parameters</li>
<li>The interpreter instance for executing code</li>
<li>Checkpoint from the journal for state rollback</li>
</ul>
<h3 id="using-checkpoints"><a class="header" href="#using-checkpoints">Using Checkpoints</a></h3>
<p>The journal (see <a href="Revm/01_context___environment_.html">Chapter 1: Context &amp; Environment</a>) supports <strong>checkpoints</strong>:</p>
<ul>
<li>When a frame starts, a checkpoint is saved.</li>
<li>If the frame finishes successfully, checkpoint commits.</li>
<li>Otherwise, checkpoint reverts changes.</li>
</ul>
<p>Simple example of checkpoint usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let checkpoint = context.journal().checkpoint();

// Execute something
let result = interpreter.run();

if result.is_success() {
    context.journal().checkpoint_commit();
} else {
    context.journal().checkpoint_revert(checkpoint);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="call-depth--limits"><a class="header" href="#call-depth--limits">Call Depth &amp; Limits</a></h3>
<p>Frames track <code>depth</code>, which is checked to ensure call stacks do not grow beyond allowed limits (<code>CALL_STACK_LIMIT</code>). Exceeding the limit immediately fails the call.</p>
<h3 id="returning-results-to-caller"><a class="header" href="#returning-results-to-caller">Returning Results to Caller</a></h3>
<p>Return data and gas are carefully passed back to the caller frame so it can continue execution, pushing return values to the stack and refunding unused gas.</p>
<hr />
<h2 id="summary-5"><a class="header" href="#summary-5">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What are frames?</strong><br />
Execution contexts for single calls or contract creations, encapsulating interpreter state, gas, memory, and checkpoints.</p>
</li>
<li>
<p><strong>Why are frames important?</strong><br />
They let <code>revm</code> support nested contract calls safely with proper state management and gas tracking.</p>
</li>
<li>
<p><strong>How the call stack works:</strong><br />
Frames are pushed on calls and popped on returns. Depth limits prevent abuse.</p>
</li>
<li>
<p><strong>Checkpointing state:</strong><br />
Frames create snapshots of the state before execution, allowing revert on call failure and commit on success.</p>
</li>
<li>
<p><strong>How inputs and outputs flow:</strong><br />
Calls supply gas, input data, value, and get back gas remaining and return data.</p>
</li>
<li>
<p><strong>Basic API usage to create and run frames:</strong></p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>EthFrame::make_call_frame(...) -&gt; Result&lt;ItemOrResult&lt;EthFrame&gt;, Error&gt;
// run interpreter and process result
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Internal flow:</strong><br />
The handler calls frame initialization, then runs the interpreter inside frames, manages state with checkpoints, and correctly returns results.</li>
</ul>
<p>This layered approach cleanly separates execution of nested calls, making it easy to understand, manage, and debug complex contract interactions!</p>
<hr />
<p>Next, we'll learn how the <strong>Handler &amp; Execution Loop</strong> uses frames to manage the entire EVM call stack and keep your contracts running smoothly. Head over to <a href="Revm/09_handler___execution_loop_.html">Chapter 9: Handler &amp; Execution Loop</a> to continue the journey!</p>
<hr />
<p>Thank you for following along! Frames and call handling are the backbone of smart contract execution, enabling nested calls and safe context switching inside the EVM. You're doing fantastic—keep going!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9-handler--execution-loop"><a class="header" href="#chapter-9-handler--execution-loop">Chapter 9: Handler &amp; Execution Loop</a></h1>
<p>Welcome back! In the previous chapter, <a href="Revm/08_frame___call_handling_.html">Frame &amp; Call Handling</a>, we learned how the EVM manages individual execution contexts called <strong>frames</strong> to run nested calls and contract creations safely. Now, we’re going to zoom out and look at the <strong>Handler &amp; Execution Loop</strong> — the high-level controller that orchestrates the full lifecycle of a transaction inside <code>revm</code>.</p>
<hr />
<h2 id="why-do-we-need-a-handler--execution-loop"><a class="header" href="#why-do-we-need-a-handler--execution-loop">Why Do We Need a Handler &amp; Execution Loop?</a></h2>
<p>Imagine you're the director of a busy kitchen during dinner rush. Your job is to:</p>
<ul>
<li>Check if all the ingredients are ready (validation),</li>
<li>Deduct ingredients when cooking starts (pre-processing),</li>
<li>Tell the chefs (interpreters) exactly what to cook step-by-step (execution),</li>
<li>Keep track of time and materials used,</li>
<li>Handle refunds if some dishes get canceled,</li>
<li>Reward the waiters or cleaners (post-processing),</li>
<li>And make sure everything finishes smoothly.</li>
</ul>
<p>Similarly, the <strong>Handler</strong> in <code>revm</code> acts as the <strong>EVM’s transaction controller</strong>. It:</p>
<ul>
<li>Orchestrates <strong>validation</strong> of transactions and environment,</li>
<li>Performs <strong>pre-execution setup</strong> like loading accounts and deducting gas upfront,</li>
<li>Manages the <strong>execution loop</strong> by creating and running frames,</li>
<li>Handles <strong>post-execution tasks</strong> like gas refunds, rewards, and finalizing state,</li>
<li>Wraps all this with error handling to keep the system robust.</li>
</ul>
<p>Simply put, if you think of the EVM as a factory, the <strong>Handler is the factory manager</strong>, keeping everything running from start to finish for a transaction.</p>
<hr />
<h2 id="central-use-case-executing-a-simple-transaction"><a class="header" href="#central-use-case-executing-a-simple-transaction">Central Use Case: Executing a Simple Transaction</a></h2>
<p>Suppose someone sends a transaction calling a smart contract to transfer tokens:</p>
<ol>
<li>The Handler first <strong>validates</strong> the transaction against the current blockchain state (e.g., does the sender have enough balance? Is the nonce correct?).</li>
<li>It then <strong>loads accounts</strong> involved and deducts gas fees up front.</li>
<li>It <strong>creates the first call frame</strong> representing this call and starts running it.</li>
<li>If during execution, the contract calls another contract, the Handler manages those nested frames.</li>
<li>When execution completes or fails, the Handler:
<ul>
<li>Calculates <strong>final gas refunds</strong>,</li>
<li>Gives <strong>unused gas back to the sender</strong>,</li>
<li>Transfers fees to the block beneficiary,</li>
<li>Collects <strong>logs</strong> and final output,</li>
<li>And <strong>cleans up</strong> internal resources.</li>
</ul>
</li>
</ol>
<p>Let's learn how the Handler achieves all this step-by-step!</p>
<hr />
<h2 id="breaking-down-the-handler--execution-loop"><a class="header" href="#breaking-down-the-handler--execution-loop">Breaking Down the Handler &amp; Execution Loop</a></h2>
<p>To understand how the Handler works, let's look at the key concepts and phases in order.</p>
<h3 id="1-validation"><a class="header" href="#1-validation">1. Validation</a></h3>
<p>Before execution begins, the Handler checks:</p>
<ul>
<li>Is the transaction properly structured?</li>
<li>Is the gas limit within the block’s gas limits?</li>
<li>Does the caller have enough balance to cover gas and value transfers?</li>
<li>Is the nonce correct (to prevent replay attacks)?</li>
<li>Are things like chain ID and config compatible?</li>
</ul>
<p>This step prevents invalid transactions from even starting.</p>
<h3 id="2-pre-execution"><a class="header" href="#2-pre-execution">2. Pre-Execution</a></h3>
<p>Here the Handler:</p>
<ul>
<li>Loads the <strong>beneficiary</strong> account (miner/coinbase),</li>
<li>Loads all <strong>accounts/storage</strong> in the access list to warm them for faster access,</li>
<li>Deducts the <strong>maximum gas cost</strong> upfront from the caller's balance to avoid double spending,</li>
<li>Applies any protocol-specific preparations (like EIP-7702 authorization lists).</li>
</ul>
<h3 id="3-execution-loop"><a class="header" href="#3-execution-loop">3. Execution Loop</a></h3>
<p>This is the heart of the Handler:</p>
<ul>
<li>It creates the <strong>initial call frame</strong> based on the transaction input.</li>
<li>It runs the <strong>execution loop</strong>, which:
<ul>
<li>Repeatedly executes frames using nested calls.</li>
<li>Manages creation and completion of each frame.</li>
<li>Handles results, propagates output and gas back to callers.</li>
</ul>
</li>
<li>Uses a <strong>frame stack</strong> to handle nested calls safely (see <a href="Revm/08_frame___call_handling_.html">Chapter 8</a>).</li>
</ul>
<h3 id="4-post-execution"><a class="header" href="#4-post-execution">4. Post-Execution</a></h3>
<p>After execution finishes (successfully or not):</p>
<ul>
<li>Calculates <strong>gas refunds</strong> and applies limits (EIP-7623 ensures minimal gas spent).</li>
<li>Returns unused gas value to the caller.</li>
<li>Sends fees to the beneficiary (miner).</li>
<li>Finalizes logs and state changes.</li>
<li>Clears internal buffers and prepares for next transaction.</li>
</ul>
<h3 id="5-error-handling"><a class="header" href="#5-error-handling">5. Error Handling</a></h3>
<p>If anything goes wrong anywhere:</p>
<ul>
<li>The Handler cleans up intermediate state.</li>
<li>Reverts journals where needed.</li>
<li>Returns proper error info.</li>
<li>Ensures the environment is ready for the next transaction.</li>
</ul>
<hr />
<h2 id="how-to-use-the-handler-a-beginner-friendly-walkthrough"><a class="header" href="#how-to-use-the-handler-a-beginner-friendly-walkthrough">How to Use the Handler: A Beginner-Friendly Walkthrough</a></h2>
<p>Let’s simulate what it looks like to run a transaction with a Handler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assume you have an EVM `evm` instance properly initialized.

struct MyHandler;

impl revm::handler::Handler for MyHandler {
    type Evm = /* Your EVM type */;
    type Error = /* Your Error type */;
    type Frame = /* Frame type, e.g., EthFrame */;
    type HaltReason = /* Halt reason type, e.g., HaltReason */;

    // Implement required trait methods here. For beginner use,
    // you can call the default implementations or simple wrappers.
}

let mut handler = MyHandler;

// Run the transaction via the handler with 'evm'
match handler.run(&amp;mut evm) {
    Ok(result_and_state) =&gt; {
        println!("Execution success! Gas used: {}", result_and_state.result.gas_used());
        println!("Output data: {:?}", result_and_state.result.output());
    }
    Err(e) =&gt; {
        println!("Execution failed with error: {:?}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>What happens here?</strong></p>
<ul>
<li>The Handler takes your <code>evm</code> instance (which contains Context, Interpreter, Precompiles, etc.).</li>
<li>It automatically goes through validation, pre-execution, execution loop, and post-execution.</li>
<li>You get a final result telling if the transaction succeeded, how much gas was used, and the contract output.</li>
<li>If any error occurs, the Handler reports it properly.</li>
</ul>
</blockquote>
<hr />
<h2 id="internal-handler--execution-loop-what-happens-step-by-step"><a class="header" href="#internal-handler--execution-loop-what-happens-step-by-step">Internal Handler &amp; Execution Loop: What Happens Step-by-Step?</a></h2>
<p>Let’s picture internally how the Handler processes a transaction.</p>
<pre class="mermaid">sequenceDiagram
    participant User as User Code
    participant Handler as Transaction Handler
    participant Context as Blockchain Context &amp; Journal
    participant FrameStack as Call Frames Stack
    participant Interpreter as EVM Bytecode Executor

    User-&gt;&gt;Handler: Call `run()` with transaction and context
    Handler-&gt;&gt;Context: Validate tx, block, and config
    Handler-&gt;&gt;Context: Load accounts and deduct max gas from caller
    Handler-&gt;&gt;FrameStack: Create initial call frame with tx input
    loop Execution Loop
        FrameStack-&gt;&gt;Interpreter: Run current frame (code execution)
        Interpreter--&gt;&gt;FrameStack: Return frame result or new nested call
        alt Nested call
            FrameStack-&gt;&gt;FrameStack: Push new frame for nested call
        else Frame complete
            FrameStack-&gt;&gt;FrameStack: Pop frame and return result to caller
        end
    end
    Handler-&gt;&gt;Context: Calculate refunds and reimburse caller
    Handler-&gt;&gt;Context: Reward block beneficiary
    Handler--&gt;&gt;User: Return execution results (gas used, output, logs)
</pre>
<h3 id="brief-explanation"><a class="header" href="#brief-explanation">Brief explanation:</a></h3>
<ul>
<li>The Handler serves as the conductor, coordinating each step carefully.</li>
<li>Context keeps track of blockchain and transaction state, managing accounts, balances, and journaling.</li>
<li>The frame stack manages each call or contract creation, allowing nesting and proper gas tracking.</li>
<li>The Interpreter runs the actual smart contract code instructions.</li>
<li>The loop continues until no more frames are left (execution done).</li>
<li>After execution, fees and refunds are finalized and rewards paid out.</li>
<li>The final status and output are returned to the user.</li>
</ul>
<hr />
<h2 id="peek-under-the-hood-core-handler-code-highlights"><a class="header" href="#peek-under-the-hood-core-handler-code-highlights">Peek Under the Hood: Core Handler Code Highlights</a></h2>
<h3 id="the-run-method-simplified"><a class="header" href="#the-run-method-simplified">The Run Method (Simplified)</a></h3>
<p>This is the entry point to the Handler (from <code>crates/handler/src/handler.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(
    &amp;mut self,
    evm: &amp;mut Self::Evm,
) -&gt; Result&lt;ResultAndState&lt;Self::HaltReason&gt;, Self::Error&gt; {
    // Step 1: Validate the transaction environment
    let init_and_floor_gas = self.validate(evm)?;

    // Step 2: Pre-execution setup, loading accounts and deducting gas
    let eip7702_refund = self.pre_execution(evm)?;

    // Step 3: Execute the transaction
    let exec_result = self.execution(evm, &amp;init_and_floor_gas)?;

    // Step 4: Post-execution tasks: refunds, reimbursements, rewards
    self.post_execution(evm, exec_result, init_and_floor_gas, eip7702_refund)
}
<span class="boring">}</span></code></pre></pre>
<p>Each of these steps calls further internal functions that perform tasks described earlier.</p>
<h3 id="the-execution-loop"><a class="header" href="#the-execution-loop">The Execution Loop</a></h3>
<p>The <code>execution</code> method runs the main loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn execution(
    &amp;mut self,
    evm: &amp;mut Self::Evm,
    init_and_floor_gas: &amp;InitialAndFloorGas,
) -&gt; Result&lt;FrameResult, Self::Error&gt; {
    let gas_limit = evm.ctx().tx().gas_limit() - init_and_floor_gas.initial_gas;

    // Create the first frame representing the transaction call
    let first_frame_input = self.first_frame_input(evm, gas_limit)?;
    let first_frame = self.first_frame_init(evm, first_frame_input)?;

    // Either start with a frame or have immediate result (like out of gas)
    let mut frame_result = match first_frame {
        ItemOrResult::Item(frame) =&gt; self.run_exec_loop(evm, frame)?,
        ItemOrResult::Result(result) =&gt; result,
    };

    // Process the last frame's result (manage gas, etc.)
    self.last_frame_result(evm, &amp;mut frame_result)?;
    Ok(frame_result)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-frame-stack-loop-simplified"><a class="header" href="#the-frame-stack-loop-simplified">The Frame Stack Loop (Simplified)</a></h3>
<p>The <code>run_exec_loop</code> method holds the frame stack loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_exec_loop(
    &amp;mut self,
    evm: &amp;mut Self::Evm,
    frame: Self::Frame,
) -&gt; Result&lt;FrameResult, Self::Error&gt; {
    let mut frame_stack = vec![frame];

    loop {
        let current_frame = frame_stack.last_mut().unwrap();
        let call_or_result = self.frame_call(current_frame, evm)?;

        let result = match call_or_result {
            ItemOrResult::Item(new_frame_input) =&gt; {
                // Create new nested frame and push it on the stack
                match self.frame_init(current_frame, evm, new_frame_input)? {
                    ItemOrResult::Item(new_frame) =&gt; {
                        frame_stack.push(new_frame);
                        continue;
                    }
                    ItemOrResult::Result(res) =&gt; res,
                }
            }
            ItemOrResult::Result(res) =&gt; {
                // Frame finished, pop from stack and handle result
                frame_stack.pop();
                res
            }
        };

        if let Some(parent_frame) = frame_stack.last_mut() {
            // Send result back to parent frame
            self.frame_return_result(parent_frame, evm, result)?;
        } else {
            // No more frames, execution complete
            return Ok(result);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="summary-6"><a class="header" href="#summary-6">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What is the Handler &amp; Execution Loop?</strong><br />
The high-level controller that manages the full lifecycle of a transaction inside the EVM runtime.</p>
</li>
<li>
<p><strong>Why it’s important?</strong><br />
It ensures transactions are validated, accounts are prepared, code executes correctly with nested calls, and gas fees/refunds are managed safely.</p>
</li>
<li>
<p><strong>Key phases of the handler:</strong><br />
Validation → Pre-execution → Execution loop → Post-execution → Error handling.</p>
</li>
<li>
<p><strong>How the execution loop works:</strong><br />
Creates call frames and manages a stack to handle nested calls and contract creations.</p>
</li>
<li>
<p><strong>How to use the Handler:</strong><br />
Call <code>handler.run(&amp;mut evm)</code> to execute a transaction with everything managed automatically.</p>
</li>
<li>
<p><strong>What happens internally:</strong><br />
The handler verifies the transaction environment, preps accounts and gas, executes frames via the interpreter, processes nested calls, and finalizes results, refunds, and fees.</p>
</li>
</ul>
<hr />
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What’s Next?</a></h2>
<p>With the Handler &amp; Execution Loop mastered, you're ready to explore how <code>revm</code> provides <strong>Inspector &amp; Tracing</strong> capabilities, letting you debug, profile, and analyze EVM execution in detail:</p>
<p>Check out <a href="Revm/10_inspector___tracing_.html">Chapter 10: Inspector &amp; Tracing</a> to continue your learning journey!</p>
<hr />
<p>Thank you for following this chapter! Understanding the Handler gives you a complete picture of how revm manages transactions from start to finish, tying everything together into a robust and flexible Ethereum Virtual Machine runtime. Keep it up!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-10-inspector--tracing"><a class="header" href="#chapter-10-inspector--tracing">Chapter 10: Inspector &amp; Tracing</a></h1>
<p>Welcome back! In the previous chapter, <a href="Revm/09_handler___execution_loop_.html">Handler &amp; Execution Loop</a>, we saw how the EVM manages the full lifecycle of transaction execution, coordinating calls, gas, and state changes. Now, it's time to explore a very powerful tool for developers and analysts: the <strong>Inspector &amp; Tracing</strong> system in <code>revm</code>.</p>
<hr />
<h2 id="why-do-we-need-an-inspector--tracing"><a class="header" href="#why-do-we-need-an-inspector--tracing">Why Do We Need an Inspector &amp; Tracing?</a></h2>
<p>Imagine you’re learning to drive a car. At first, you just want to press the gas and steer, but as you get better, you might want to watch a special dashboard that shows exactly how your car behaves:</p>
<ul>
<li>How fast you are now,</li>
<li>How much fuel you’re using,</li>
<li>When you press the brake or accelerator,</li>
<li>Which gear you’re in,</li>
<li>And even a replay of your trip step-by-step.</li>
</ul>
<p>Similarly, when running smart contracts inside the EVM, it’s super useful to <strong>peek inside the “engine”</strong> to see exactly what happens at every execution step:</p>
<ul>
<li>Which instructions run,</li>
<li>What’s on the stack,</li>
<li>When logs are generated,</li>
<li>Calls and creations made,</li>
<li>How gas is spent,</li>
<li>And even to modify behavior for debugging or analysis.</li>
</ul>
<p>This is what the <strong>Inspector &amp; Tracing system</strong> in <code>revm</code> provides — <strong>debugging hooks and tracing points into the EVM execution engine</strong>.</p>
<hr />
<h2 id="central-use-case-debugging-a-smart-contract-execution"><a class="header" href="#central-use-case-debugging-a-smart-contract-execution">Central Use Case: Debugging a Smart Contract Execution</a></h2>
<p>Suppose you wrote a contract but it behaves unexpectedly — maybe it runs out of gas prematurely, or a conditional jump goes to the wrong place, or logs aren’t emitted correctly.</p>
<p>With a simple call, you want to:</p>
<ol>
<li>Step through your contract code instruction-by-instruction,</li>
<li>See the stack and memory state at each point,</li>
<li>Observe when logs or calls happen,</li>
<li>Track gas usage in detail,</li>
<li>And if needed, stop or modify execution at certain points.</li>
</ol>
<p>The <strong>Inspector</strong> lets you hook into all these steps easily, like attaching a debugger or a monitoring system to your EVM execution.</p>
<hr />
<h2 id="breaking-down-the-inspector--tracing-system"><a class="header" href="#breaking-down-the-inspector--tracing-system">Breaking Down the Inspector &amp; Tracing System</a></h2>
<p>Let's break it into beginner-friendly parts:</p>
<h3 id="1-inspector-trait"><a class="header" href="#1-inspector-trait">1. <strong>Inspector Trait</strong></a></h3>
<ul>
<li>A <em>trait</em> (or interface) that you implement to get notifications about EVM execution.</li>
<li>It provides methods called at key moments such as:
<ul>
<li>When the interpreter initializes,</li>
<li>Before and after every instruction,</li>
<li>When a log is emitted,</li>
<li>When a call or contract creation starts or ends,</li>
<li>When a contract self-destructs.</li>
</ul>
</li>
<li>You can log, store, analyze or even modify execution flow in these hooks.</li>
</ul>
<h3 id="2-hooks-during-execution"><a class="header" href="#2-hooks-during-execution">2. <strong>Hooks During Execution</strong></a></h3>
<ul>
<li><strong>Initialize Interp</strong>: Called once before code execution starts.</li>
<li><strong>Step</strong>: Called before executing every instruction.</li>
<li><strong>Step End</strong>: Called right after each instruction finishes.</li>
<li><strong>Log</strong>: Called whenever an event log is emitted.</li>
<li><strong>Call</strong>: Called before a new contract call or creation.</li>
<li><strong>Call End</strong>: Called right after the call finishes.</li>
<li><strong>Create</strong> &amp; <strong>Create End</strong>: Similar to call hooks for contract creation.</li>
<li><strong>Selfdestruct</strong>: Called when a contract self-destructs.</li>
</ul>
<h3 id="3-integration-with-evm"><a class="header" href="#3-integration-with-evm">3. <strong>Integration with EVM</strong></a></h3>
<ul>
<li>The <code>Inspector</code> is plugged into the EVM runtime.</li>
<li><code>revm</code> calls inspector hooks automatically during execution.</li>
<li>Multiple inspectors can be composed if needed.</li>
<li>Even though powerful, these hooks are optional, so normal execution remains fast without them.</li>
</ul>
<h3 id="4-journal-extensions"><a class="header" href="#4-journal-extensions">4. <strong>Journal Extensions</strong></a></h3>
<ul>
<li>The inspector also works closely with the <strong>state journaling system</strong> to access logs and state changes.</li>
<li>Inspector can read these journals to obtain detailed info about execution.</li>
</ul>
<hr />
<h2 id="how-to-use-the-inspector-in-practice"><a class="header" href="#how-to-use-the-inspector-in-practice">How to Use the Inspector in Practice</a></h2>
<p>Here’s a super simple example of implementing a basic inspector that logs each executed instruction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::{
    interpreter::{Interpreter, EthInterpreter, InterpreterTypes},
    inspector::Inspector,
};
use context::Context;
use primitives::U256;

struct SimpleLogger;

impl&lt;CTX&gt; Inspector&lt;CTX, EthInterpreter&gt; for SimpleLogger {
    fn step(&amp;mut self, interp: &amp;mut Interpreter&lt;EthInterpreter&gt;, _ctx: &amp;mut CTX) {
        let pc = interp.bytecode.pc();
        let opcode = interp.current_opcode();
        let stack = &amp;interp.stack;
        println!(
            "Executing instruction at PC {}: opcode 0x{:x}, Stack size: {}",
            pc,
            opcode,
            stack.len()
        );
    }

    fn log(&amp;mut self, _interp: &amp;mut Interpreter&lt;EthInterpreter&gt;, _ctx: &amp;mut CTX, log: primitives::Log) {
        println!("Log emitted: {:?}", log);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>We define <code>SimpleLogger</code> struct.</li>
<li>It implements the <code>Inspector</code> trait.</li>
<li>On every instruction step, it prints program counter, opcode, and current stack size.</li>
<li>When a log is emitted, it prints the log info.</li>
</ul>
<h3 id="plugging-the-inspector-into-your-evm"><a class="header" href="#plugging-the-inspector-into-your-evm">Plugging the Inspector into your EVM:</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut context = Context::new(EmptyDB, SpecId::LATEST);
// ... set up context with transaction and block ...

// Create your EVM runtime with your inspector
let mut evm = context.build_mainnet_with_inspector(SimpleLogger);

// Run your EVM with inspector enabled!
let _ = evm.inspect_replay();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>This will print every instruction and emitted log during contract execution, helping you understand what’s happening inside!</p>
</blockquote>
<hr />
<h2 id="what-happens-internally-step-by-step-inspection-flow"><a class="header" href="#what-happens-internally-step-by-step-inspection-flow">What Happens Internally? Step-by-Step Inspection Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant EVM as EVM Interpreter
    participant Inspector as Inspector Hooks
    participant Context as Blockchain Context &amp; Journal

    EVM-&gt;&gt;Inspector: initialize_interp()
    loop For every instruction
        EVM-&gt;&gt;Inspector: step() - before instruction
        EVM-&gt;&gt;EVM: execute instruction
        EVM-&gt;&gt;Inspector: step_end() - after instruction
        alt Instruction emits a log
            EVM-&gt;&gt;Inspector: log()
        end
    end
    alt Contract call or create
        EVM-&gt;&gt;Inspector: call()/create()
        [Execution of called contract]
        EVM-&gt;&gt;Inspector: call_end()/create_end()
    end
    alt Contract selfdestruct
        EVM-&gt;&gt;Inspector: selfdestruct()
    end
</pre>
<h3 id="explanation-6"><a class="header" href="#explanation-6">Explanation:</a></h3>
<ul>
<li>Before the interpreter starts, Inspector’s <code>initialize_interp</code> is called.</li>
<li>For each instruction:
<ul>
<li><code>step</code> is called to inspect before execution.</li>
<li>Interpreter runs the instruction.</li>
<li><code>step_end</code> is called after execution.</li>
</ul>
</li>
<li>If the instruction emits a log, <code>log</code> is called.</li>
<li>When a contract call or creation starts and ends, respective hooks are invoked.</li>
<li>If a contract selfdestructs, the inspector gets notified with the contract and target info.</li>
</ul>
<hr />
<h2 id="diving-deeper-into-the-code-core-inspector-trait"><a class="header" href="#diving-deeper-into-the-code-core-inspector-trait">Diving Deeper into the Code: Core Inspector Trait</a></h2>
<p>From the file <code>crates/inspector/src/inspector.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Inspector&lt;CTX, INTR: InterpreterTypes = EthInterpreter&gt; {
    fn initialize_interp(&amp;mut self, interp: &amp;mut Interpreter&lt;INTR&gt;, context: &amp;mut CTX) { }
    fn step(&amp;mut self, interp: &amp;mut Interpreter&lt;INTR&gt;, context: &amp;mut CTX) { }
    fn step_end(&amp;mut self, interp: &amp;mut Interpreter&lt;INTR&gt;, context: &amp;mut CTX) { }
    fn log(&amp;mut self, interp: &amp;mut Interpreter&lt;INTR&gt;, context: &amp;mut CTX, log: Log) { }
    fn call(&amp;mut self, context: &amp;mut CTX, inputs: &amp;mut CallInputs) -&gt; Option&lt;CallOutcome&gt; { None }
    fn call_end(&amp;mut self, context: &amp;mut CTX, inputs: &amp;CallInputs, outcome: &amp;mut CallOutcome) { }
    fn create(&amp;mut self, context: &amp;mut CTX, inputs: &amp;mut CreateInputs) -&gt; Option&lt;CreateOutcome&gt; { None }
    fn create_end(&amp;mut self, context: &amp;mut CTX, inputs: &amp;CreateInputs, outcome: &amp;mut CreateOutcome) { }
    fn selfdestruct(&amp;mut self, contract: Address, target: Address, value: U256) { }
    // Other hooks omitted for brevity...
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>All methods have default empty implementations.</li>
<li>You override the ones relevant for your use case.</li>
<li>Returning something from <code>call</code> or <code>create</code> can override the execution result (helpful for debugging or simulating).</li>
</ul>
<hr />
<h2 id="how-inspector-integrates-with-the-handler--execution-loop"><a class="header" href="#how-inspector-integrates-with-the-handler--execution-loop">How Inspector Integrates with the Handler &amp; Execution Loop</a></h2>
<p>The handler in <code>revm</code> supports an <code>InspectorHandler</code> trait, which extends the normal <code>Handler</code> with inspector hooks.</p>
<p>When running the EVM with inspection enabled:</p>
<ul>
<li>The handler calls <strong>inspector-aware versions</strong> of execution functions.</li>
<li>The interpreter calls the <code>step</code> and <code>step_end</code> hooks during its instruction loop.</li>
<li>The inspector also receives call and create notifications for better visibility into nested executions.</li>
</ul>
<p>Here’s a simplified snippet from <code>crates/inspector/src/handler.rs</code> showing how the inspector is called during the frame execution loop:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn inspect_run_exec_loop(
    &amp;mut self,
    evm: &amp;mut Self::Evm,
    frame: Self::Frame,
) -&gt; Result&lt;FrameResult, Self::Error&gt; {
    let mut frame_stack: Vec&lt;Self::Frame&gt; = vec![frame];
    loop {
        let frame = frame_stack.last_mut().unwrap();
        let call_or_result = self.inspect_frame_call(frame, evm)?;

        let result = match call_or_result {
            ItemOrResult::Item(mut init) =&gt; {
                if let Some(output) = frame_start(context, inspector, &amp;mut init) {
                    output
                } else {
                    // create sub frame...
                }
            }
            ItemOrResult::Result(mut result) =&gt; {
                frame_end(context, inspector, frame.frame_input(), &amp;mut result);
                frame_stack.pop();
                result
            }
        };

        // returning results to caller frame or exit when no frames remain...
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Before and after each frame execution, the inspector’s call or create hooks are activated.</li>
<li>The interpreter steps inside frames call inspector's <code>step</code> and <code>step_end</code>.</li>
<li>Logs and selfdestructs trigger inspector calls too.</li>
</ul>
<hr />
<h2 id="advanced-tip-using-the-inspector-for-gas-profiling"><a class="header" href="#advanced-tip-using-the-inspector-for-gas-profiling">Advanced Tip: Using the Inspector for Gas Profiling</a></h2>
<p>There is also a <code>GasInspector</code> in <code>crates/inspector/src/gas.rs</code> that tracks gas usage step-by-step.</p>
<p>Example usage snippet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GasProfiler {
    last_gas: u64,
}

impl&lt;CTX&gt; Inspector&lt;CTX, EthInterpreter&gt; for GasProfiler {
    fn initialize_interp(&amp;mut self, interp: &amp;mut Interpreter&lt;EthInterpreter&gt;, _ctx: &amp;mut CTX) {
        self.last_gas = interp.control.gas().remaining();
    }

    fn step_end(&amp;mut self, interp: &amp;mut Interpreter&lt;EthInterpreter&gt;, _ctx: &amp;mut CTX) {
        let current_gas = interp.control.gas().remaining();
        let spent = self.last_gas - current_gas;
        println!("Gas spent on this instruction: {}", spent);
        self.last_gas = current_gas;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This helps analyze which instructions consume the most gas in your contract execution.</p>
<hr />
<h2 id="summary-7"><a class="header" href="#summary-7">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What is Inspector &amp; Tracing?</strong><br />
A system of hooks providing detailed introspection into EVM execution, like a debugger and system monitor.</p>
</li>
<li>
<p><strong>Why is it useful?</strong><br />
To debug, profile, and analyze smart contract execution step-by-step.</p>
</li>
<li>
<p><strong>Key Concepts:</strong><br />
Inspector trait hooks (<code>step</code>, <code>step_end</code>, <code>log</code>, <code>call</code>, <code>create</code>, <code>selfdestruct</code>), integration with interpreter and handler, journal extensions.</p>
</li>
<li>
<p><strong>How to use it:</strong><br />
Implement the <code>Inspector</code> trait for your struct, override desired hooks, and plug it into your EVM runtime.</p>
</li>
<li>
<p><strong>What happens internally:</strong><br />
Inspector methods are called at appropriate execution events, allowing custom logic to observe or modify EVM execution flow.</p>
</li>
<li>
<p><strong>How it fits into <code>revm</code> architecture:</strong><br />
Works closely with the interpreter, handler, context, and journaling layers to give you a full view of running contracts.</p>
</li>
</ul>
<hr />
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What’s Next?</a></h2>
<p>You now have a powerful tool to peek into EVM execution. With inspectors, you can trace, debug, and understand smart contracts like never before!</p>
<p>The next chapters may explore optional tooling, integrations, or focus on performance aspects.</p>
<p>Thank you for following along in this exciting journey through <code>revm</code> — your window into the Ethereum Virtual Machine internals!</p>
<p>Happy debugging! 🚀</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
