<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>State &amp; Database Layers - Tutorial Codebase Knowledge</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tutorial Codebase Knowledge</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-3-state--database-layers"><a class="header" href="#chapter-3-state--database-layers">Chapter 3: State &amp; Database Layers</a></h1>
<p>Welcome back! In <a href="02_host_interface_.html">Chapter 2: Host Interface</a>, we learned how the EVM talks to the blockchain environment to read account balances, storage, and block info. Now, we’ll dig deeper into <strong>how the blockchain state is actually stored, organized, and updated inside revm</strong>.</p>
<hr />
<h2 id="why-do-we-need-state--database-layers"><a class="header" href="#why-do-we-need-state--database-layers">Why do we need State &amp; Database Layers?</a></h2>
<p>Imagine you’re managing a huge library. Visitors can borrow books, return them, or add new ones. You need a system that:</p>
<ul>
<li>Remembers who owns what book.</li>
<li>Keeps track of books available on the shelves.</li>
<li>Allows you to update records in real-time.</li>
<li>Lets you rollback changes if a mistake happens.</li>
</ul>
<p>In Ethereum (and thus in EVM), the "library" is the <strong>blockchain state</strong>: all accounts, their balances, nonces, smart contract code, and storage (key-value data inside contracts).</p>
<p>The <strong>State &amp; Database Layers</strong> in revm handle:</p>
<ul>
<li>Loading this data from some permanent storage (database).</li>
<li>Caching it while the EVM is executing (so repeated reads are fast).</li>
<li>Managing changes safely, so they can be committed or reverted.</li>
<li>Organizing account details, storage slots, and bytecode in structures that are efficient and easy to update.</li>
</ul>
<p>In short: <strong>This is the persistent storage backend for the EVM</strong>, where everything that smart contracts read/write really “lives.”</p>
<hr />
<h2 id="a-concrete-scenario-reading-and-updating-account-storage"><a class="header" href="#a-concrete-scenario-reading-and-updating-account-storage">A Concrete Scenario: Reading and Updating Account Storage</a></h2>
<p>Let’s say a smart contract running in the EVM wants to:</p>
<ol>
<li>Read the current value stored at a specific key in its storage.</li>
<li>Modify that value to a new number.</li>
<li>Deduct some balance from the sender account.</li>
<li>Update the nonce to prevent replay.</li>
<li>Eventually commit all these changes to make them permanent.</li>
</ol>
<p>How do we organize this flow so the EVM can do all those steps efficiently and safely?</p>
<p>The State &amp; Database Layers provide this solution.</p>
<hr />
<h2 id="key-concepts-in-state--database-layers"><a class="header" href="#key-concepts-in-state--database-layers">Key Concepts in State &amp; Database Layers</a></h2>
<p>Let’s break down the building blocks of this system in simple terms:</p>
<h3 id="1-database"><a class="header" href="#1-database">1. <strong>Database</strong></a></h3>
<ul>
<li>Think of this as the <strong>permanent filing cabinet</strong>.</li>
<li>It holds <em>all</em> the accounts and their data before any new transaction runs.</li>
<li>It stores:
<ul>
<li>Account information: balances, nonces, code hash.</li>
<li>Contract bytecode.</li>
<li>Storage key-value pairs for each account.</li>
<li>Block hashes by block number.</li>
</ul>
</li>
<li>Usually, it is slow to access because it might be on disk or remote.</li>
</ul>
<p><strong>Example:</strong> <code>EmptyDB</code> is a built-in simple database that acts like an empty filing cabinet with default empty data. It is mostly used for testing.</p>
<hr />
<h3 id="2-cache-layer"><a class="header" href="#2-cache-layer">2. <strong>Cache Layer</strong></a></h3>
<ul>
<li>Think of this as your <strong>desktop where you keep frequently used files</strong>.</li>
<li>The cache stores data that has been loaded from the database.</li>
<li>It allows fast repeated reads and quick writes <em>before committing</em> changes.</li>
<li>It holds accounts and storage slots that the EVM reads or modifies during execution.</li>
<li>It also keeps track of logs and modified contract bytecode.</li>
</ul>
<p><strong>Example:</strong> <code>CacheDB</code> is a cache implementation that wraps a database. It will first check cache entries before asking the database.</p>
<hr />
<h3 id="3-state"><a class="header" href="#3-state">3. <strong>State</strong></a></h3>
<ul>
<li>The <strong>“state”</strong> is the interface exposed to the EVM to <strong>read and write blockchain data</strong>.</li>
<li>It hides the complexity of caching and persistent storage behind simple calls.</li>
<li>State manages:
<ul>
<li>Loading accounts when needed.</li>
<li>Reading/writing storage slots.</li>
<li>Committing or reverting changes after execution.</li>
</ul>
</li>
<li>It supports transitions, which are the changes during a transaction or block.</li>
</ul>
<hr />
<h3 id="4-transition-state--bundle"><a class="header" href="#4-transition-state--bundle">4. <strong>Transition State &amp; Bundle</strong></a></h3>
<ul>
<li>To support rollbacks, the system stores <strong>“transitions”</strong> — changes made during transaction execution that are <em>not</em> yet final.</li>
<li>If the transaction fails or reverts, these can be discarded.</li>
<li>Completed transitions are merged into a <strong>“bundle”</strong>, which represents a finalized snapshot of state changes after a block.</li>
<li>This approach ensures history and safety in state updates.</li>
</ul>
<hr />
<h2 id="what-does-this-layer-look-like-in-code"><a class="header" href="#what-does-this-layer-look-like-in-code">What Does This Layer Look Like in Code?</a></h2>
<p>Here’s a minimal snippet creating an empty cache wrapping an empty database and reading an account info:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::database::{CacheDB, EmptyDB};
use primitives::Address;

// Create an empty database — no data yet
let db = EmptyDB::default();

// Wrap it with a cache for faster access
let mut cache_db = CacheDB::new(db);

// Pick an address (all zeros here for example)
let address = Address::zero();

// Try to get account data (balance, nonce)
let account_info = cache_db.basic(address).unwrap();

println!("Account info for {:?}: {:?}", address, account_info);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li>We create an empty database with no accounts.</li>
<li>Wrap it in a cache so if we add data later it will be stored in-memory first.</li>
<li>Query account basic info. For an empty database this will be <code>None</code>.</li>
<li>This shows reading from the database with caching.</li>
</ul>
</blockquote>
<hr />
<h2 id="reading-and-updating-storage-example"><a class="header" href="#reading-and-updating-storage-example">Reading and Updating Storage Example</a></h2>
<p>Let’s simulate loading a storage slot and then updating it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use primitives::{Address, U256};

// The address and storage slot key we want to access
let address = Address::zero();
let storage_key = U256::zero();

// Read from storage (returns U256::ZERO if missing)
let value_before = cache_db.storage(address, storage_key).unwrap();
println!("Old storage value: {}", value_before);

// Update the storage value — say setting it to 42
cache_db.insert_account_storage(address, storage_key, U256::from(42)).unwrap();

// Read again, now it should return 42
let value_after = cache_db.storage(address, storage_key).unwrap();
println!("New storage value: {}", value_after);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li>We read storage key <code>0</code> for <code>address 0x0</code>. It returns the stored value or zero if not present.</li>
<li>We then insert a new storage value (<code>42</code>) to the in-memory cache.</li>
<li>Reading again shows the updated value.</li>
</ul>
<p><strong>Note:</strong> These changes are in-memory only until committed.</p>
</blockquote>
<hr />
<h2 id="committing-state-changes"><a class="header" href="#committing-state-changes">Committing State Changes</a></h2>
<p>After all updates are done (e.g., EVM execution succeeded), the cache can be committed or merged with the underlying database.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use primitives::HashMap;
use state::Account;

// Prepare changes to commit
let mut changes = HashMap::new();

// Here suppose we create a simple account change for address
let account_change = Account {
    info: /* updated AccountInfo */,
    storage: /* updated storage HashMap */,
};

changes.insert(address, account_change);

// Commit changes to cache_db
cache_db.commit(changes);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Explanation:</strong></p>
<ul>
<li>This example shows you can batch changes into a <code>HashMap</code> of updated accounts.</li>
<li>Committing will update the cache with the latest info, preparing it for final persistence.</li>
<li>Typically the database commit happens after the full block/transaction batch.</li>
</ul>
</blockquote>
<hr />
<h2 id="what-happens-internally-step-by-step-flow"><a class="header" href="#what-happens-internally-step-by-step-flow">What Happens Internally? Step-by-step Flow</a></h2>
<p>Imagine the EVM requests a storage value or updates account balance during execution:</p>
<pre class="mermaid">sequenceDiagram
    participant EVM as EVM Interpreter
    participant State as State Layer
    participant Cache as Cache Layer
    participant DB as Persistent Database

    EVM-&gt;&gt;State: Request storage at (address, key)
    State-&gt;&gt;Cache: Check cached storage slot
    alt Storage in cache
        Cache--&gt;&gt;State: Return cached value
    else Storage not in cache
        Cache-&gt;&gt;DB: Load storage slot value
        DB--&gt;&gt;Cache: Return storage value
        Cache--&gt;&gt;State: Return loaded value
    end
    State--&gt;&gt;EVM: Provide storage value

    EVM-&gt;&gt;State: Update storage at (address, key) with new value
    State-&gt;&gt;Cache: Store new value in cache (in-memory)
    Cache--&gt;&gt;State: Confirm update
    State--&gt;&gt;EVM: Update successful

    EVM-&gt;&gt;State: Commit changes after execution
    State-&gt;&gt;Cache: Merge changes into database or flush
    Cache-&gt;&gt;DB: Write updated accounts and storage persistently
    DB--&gt;&gt;Cache: Confirm commit
    Cache--&gt;&gt;State: Commit successful
    State--&gt;&gt;EVM: Changes finalized
</pre>
<hr />
<h2 id="under-the-hood-how-does-revm-implement-this"><a class="header" href="#under-the-hood-how-does-revm-implement-this">Under the Hood: How Does revm Implement This?</a></h2>
<p>Let’s peek inside the main pieces with simplified code excerpts and explanations.</p>
<hr />
<h3 id="1-database-trait"><a class="header" href="#1-database-trait">1. <strong>Database Trait</strong></a></h3>
<p>The <code>Database</code> trait defines the low-level interface any database must provide:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Database {
    type Error;

    fn basic(&amp;mut self, address: Address) -&gt; Result&lt;Option&lt;AccountInfo&gt;, Self::Error&gt;;
    fn code_by_hash(&amp;mut self, code_hash: B256) -&gt; Result&lt;Bytecode, Self::Error&gt;;
    fn storage(&amp;mut self, address: Address, index: U256) -&gt; Result&lt;U256, Self::Error&gt;;
    fn block_hash(&amp;mut self, number: u64) -&gt; Result&lt;B256, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>basic</code> returns basic info about an account (balance, nonce, etc.).</li>
<li><code>code_by_hash</code> returns the contract bytecode for a hash.</li>
<li><code>storage</code> returns the value stored at a particular slot.</li>
<li><code>block_hash</code> returns historic block hash.</li>
</ul>
<hr />
<h3 id="2-emptydb-a-minimal-implementation"><a class="header" href="#2-emptydb-a-minimal-implementation">2. <strong>EmptyDB: A Minimal Implementation</strong></a></h3>
<p>Here's how <code>EmptyDB</code> behaves: all queries return empty/default values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Database for EmptyDB {
    type Error = Infallible;

    fn basic(&amp;mut self, _address: Address) -&gt; Result&lt;Option&lt;AccountInfo&gt;, Self::Error&gt; {
        Ok(None) // No accounts exist
    }

    fn code_by_hash(&amp;mut self, _code_hash: B256) -&gt; Result&lt;Bytecode, Self::Error&gt; {
        Ok(Bytecode::default()) // Empty code
    }

    fn storage(&amp;mut self, _address: Address, _index: U256) -&gt; Result&lt;U256, Self::Error&gt; {
        Ok(U256::ZERO) // Storage empty by default
    }

    fn block_hash(&amp;mut self, number: u64) -&gt; Result&lt;B256, Self::Error&gt; {
        // Deterministic hash of block number (for tests)
        Ok(keccak256(number.to_string().as_bytes()))
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Why is this useful?</strong><br />
It can be used for testing without any real blockchain data.</p>
</blockquote>
<hr />
<h3 id="3-cachedb-the-cache-layer"><a class="header" href="#3-cachedb-the-cache-layer">3. <strong>CacheDB: The Cache Layer</strong></a></h3>
<p><code>CacheDB</code> sits on top of any database and stores in-memory copies of accounts and storage.</p>
<p>Example of loading an account or filling cache if missing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB: DatabaseRef&gt; CacheDB&lt;ExtDB&gt; {
    pub fn load_account(&amp;mut self, address: Address) -&gt; Result&lt;&amp;mut DbAccount, ExtDB::Error&gt; {
        if let Some(account) = self.cache.accounts.get_mut(&amp;address) {
            return Ok(account);
        }
        // Load from database if not cached
        let info = self.db.basic_ref(address)?;
        let db_account = info.map(DbAccount::from).unwrap_or_else(DbAccount::new_not_existing);
        self.cache.accounts.insert(address, db_account);
        self.cache.accounts.get_mut(&amp;address).unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Checks if the account is cached; if not, loads from the underlying database.</li>
<li>Stores it in the cache for faster future access.</li>
<li>Storage slots inside accounts are also cached similarly.</li>
</ul>
<hr />
<h3 id="4-reading-storage-in-cache"><a class="header" href="#4-reading-storage-in-cache">4. <strong>Reading Storage in Cache</strong></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB: DatabaseRef&gt; CacheDB&lt;ExtDB&gt; {
    pub fn storage(&amp;mut self, address: Address, index: U256) -&gt; Result&lt;U256, ExtDB::Error&gt; {
        let account = self.load_account(address)?;
        if let Some(value) = account.storage.get(&amp;index) {
            Ok(*value)
        } else {
            // If storage is unknown, fetch from DB and cache it
            let value = self.db.storage_ref(address, index)?;
            account.storage.insert(index, value);
            Ok(value)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Looks up storage key in the cached account.</li>
<li>If missing, loads from database and caches for later.</li>
</ul>
<hr />
<h3 id="5-inserting-or-updating-storage"><a class="header" href="#5-inserting-or-updating-storage">5. <strong>Inserting or Updating Storage</strong></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB&gt; CacheDB&lt;ExtDB&gt; {
    pub fn insert_account_storage(&amp;mut self, address: Address, slot: U256, value: U256) -&gt; Result&lt;(), ExtDB::Error&gt; {
        let account = self.load_account(address)?;
        account.storage.insert(slot, value);
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Updates the storage slot directly in the cache.</li>
<li>Changes are kept in memory, not persisted immediately.</li>
</ul>
<hr />
<h3 id="6-commit-changes"><a class="header" href="#6-commit-changes">6. <strong>Commit Changes</strong></a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;ExtDB: DatabaseCommit&gt; DatabaseCommit for CacheDB&lt;ExtDB&gt; {
    fn commit(&amp;mut self, changes: HashMap&lt;Address, Account&gt;) {
        for (address, account) in changes {
            if account.is_selfdestructed() {
                // Clear account and storage
                let db_account = self.cache.accounts.entry(address).or_default();
                db_account.storage.clear();
                db_account.info = AccountInfo::default();
                continue;
            }

            self.insert_contract(&amp;mut account.info);

            // Update cached account
            self.cache.accounts.insert(address, DbAccount::from(account.info));
            // Update storage slots as well
            // Simplified here for brevity
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Applies a batch of account changes to the cache.</li>
<li>Handles contract creation, deletion, and storage update.</li>
<li>Commit to the underlying database happens after merging bundles or finalization.</li>
</ul>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter you learned:</p>
<ul>
<li>
<p><strong>Why State &amp; Database Layers exist:</strong><br />
They provide the persistent storage backend that holds account balances, nonces, contract code, and storage slots.</p>
</li>
<li>
<p><strong>Key components:</strong></p>
<ul>
<li><code>Database</code>: permanent storage interface</li>
<li><code>CacheDB</code>: in-memory cache wrapping the database for fast reads/writes</li>
<li><code>State</code>: manages cached data, transitions, and bundling changes</li>
<li>Transitions &amp; Bundles: for supporting rollbacks and batching block changes</li>
</ul>
</li>
<li>
<p><strong>How EVM reads and writes data:</strong><br />
State tries to read from cache, then falls back on the database. Writes go to cache and are merged before committing.</p>
</li>
<li>
<p><strong>How the commit process works:</strong><br />
Changes are batched and committed, enabling safe state transitions during blocks.</p>
</li>
</ul>
<p>Understanding these layers helps you grasp how revm efficiently manages the "world state" your contracts interact with!</p>
<hr />
<p>Up next, we will explore how the EVM manages gas during execution — from simple counting to advanced rules. Stay tuned for <a href="04_gas_management_.html">Chapter 4: Gas Management</a>!</p>
<hr />
<p>Thank you for following along! You’re getting deeper into the inner workings of revm, and with this, you now know where the blockchain state really lives and how it changes safely. Keep going!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Revm/02_host_interface_.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Revm/04_gas_management_.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Revm/02_host_interface_.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Revm/04_gas_management_.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
