<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interpreter - Tutorial Codebase Knowledge</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tutorial Codebase Knowledge</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-7-interpreter"><a class="header" href="#chapter-7-interpreter">Chapter 7: Interpreter</a></h1>
<p>Welcome back! In the previous chapter, we explored <a href="06_precompiles_.html">Precompiles</a> — those special native contracts that do heavy lifting like cryptography outside of the regular EVM bytecode. Now, let's dive into the heart of the <code>revm</code> project: the <strong>Interpreter</strong>.</p>
<hr />
<h2 id="what-is-the-interpreter-and-why-do-we-need-it"><a class="header" href="#what-is-the-interpreter-and-why-do-we-need-it">What is the Interpreter and Why Do We Need It?</a></h2>
<p>Think of the <strong>Interpreter</strong> as the <strong>engine</strong> or the <strong>virtual CPU</strong> of the Ethereum Virtual Machine (EVM). Its job is to:</p>
<ul>
<li><strong>Read</strong> smart contract bytecode instruction-by-instruction.</li>
<li><strong>Execute</strong> each instruction in the correct order.</li>
<li><strong>Manage</strong> the EVM stack, memory, and program counter (the pointer to the current instruction).</li>
<li>Keep track of <strong>gas</strong> usage for each operation.</li>
<li>Handle operations such as arithmetic, data loading, contract calls, and control flow (jumps, conditionals).</li>
<li>Manage interactions with the <strong>host</strong> (the blockchain environment).</li>
<li>Control when execution stops or returns results/errors.</li>
</ul>
<p>Put simply: <strong>the Interpreter makes your smart contract code come to life!</strong></p>
<hr />
<h2 id="central-use-case-running-a-simple-smart-contract-function"><a class="header" href="#central-use-case-running-a-simple-smart-contract-function">Central Use Case: Running a Simple Smart Contract Function</a></h2>
<p>Imagine you deployed a smart contract with bytecode that just:</p>
<ol>
<li>Pushes the number 2 onto the stack.</li>
<li>Pushes the number 3 onto the stack.</li>
<li>Adds these two numbers.</li>
<li>Stops execution and returns the result.</li>
</ol>
<p>The Interpreter reads these instructions one by one and executes them:</p>
<ul>
<li>Stack after first instruction: [2]</li>
<li>Stack after second instruction: [2, 3]</li>
<li>After <code>ADD</code>: pops 3 and 2, pushes 5 → stack is now [5]</li>
<li><code>STOP</code> ends execution, output is 5</li>
</ul>
<p>The Interpreter handles all of this automatically by interpreting the bytecode.</p>
<hr />
<h2 id="breaking-down-the-interpreter-key-concepts"><a class="header" href="#breaking-down-the-interpreter-key-concepts">Breaking Down the Interpreter: Key Concepts</a></h2>
<p>Let's explore the core parts the Interpreter manages:</p>
<h3 id="1-bytecode--program-counter"><a class="header" href="#1-bytecode--program-counter">1. <strong>Bytecode &amp; Program Counter</strong></a></h3>
<ul>
<li>The Interpreter holds the smart contract's bytecode.</li>
<li>A <strong>program counter (PC)</strong> points to the current instruction's byte offset.</li>
<li>After executing each instruction, PC moves forward (or jumps elsewhere for control flow).</li>
</ul>
<h3 id="2-stack"><a class="header" href="#2-stack">2. <strong>Stack</strong></a></h3>
<ul>
<li>EVM uses a <strong>stack machine</strong>: operations push and pop values on an internal stack.</li>
<li>Stack size is limited (max 1024 entries).</li>
<li>Instructions consume (pop) some values and produce (push) new ones.</li>
</ul>
<h3 id="3-memory"><a class="header" href="#3-memory">3. <strong>Memory</strong></a></h3>
<ul>
<li>Temporary memory for contracts during execution.</li>
<li>Supports reading and writing 32-byte words.</li>
<li>Memory can grow dynamically but costs gas (tracked by Gas).</li>
</ul>
<h3 id="4-gas-management"><a class="header" href="#4-gas-management">4. <strong>Gas Management</strong></a></h3>
<ul>
<li>Every instruction consumes gas.</li>
<li>Interpreter consults gas tracker to check if there's enough gas.</li>
<li>Stops execution if gas runs out.</li>
</ul>
<h3 id="5-host-interaction"><a class="header" href="#5-host-interaction">5. <strong>Host Interaction</strong></a></h3>
<ul>
<li>Some instructions (like <code>SLOAD</code> or <code>CALL</code>) need to interact with the blockchain state.</li>
<li>Interpreter calls the <strong>Host Interface</strong> to perform these operations safely.</li>
</ul>
<h3 id="6-instruction-table"><a class="header" href="#6-instruction-table">6. <strong>Instruction Table</strong></a></h3>
<ul>
<li>Interpreter uses a lookup table mapping opcode bytes to functions.</li>
<li>Each instruction function implements the behavior of one opcode.</li>
</ul>
<h3 id="7-control-flags--execution-flow"><a class="header" href="#7-control-flags--execution-flow">7. <strong>Control Flags &amp; Execution Flow</strong></a></h3>
<ul>
<li>Handles stopping, reverting, errors.</li>
<li>Can manage subroutine calls (<code>CALL</code>, <code>CREATE</code>).</li>
</ul>
<hr />
<h2 id="how-to-use-the-interpreter-a-simple-example"><a class="header" href="#how-to-use-the-interpreter-a-simple-example">How to Use the Interpreter: A Simple Example</a></h2>
<p>Here’s a beginner-friendly Rust snippet that creates an interpreter and runs simple bytecode.</p>
<pre><pre class="playground"><code class="language-rust">use revm::interpreter::{Interpreter, instruction_table};
use bytecode::Bytecode;
use primitives::{Bytes, Address, U256};

fn main() {
    // Simple bytecode: PUSH1 2, PUSH1 3, ADD, STOP
    let code: Bytes = Bytes::from_static(&amp;[0x60, 0x02, 0x60, 0x03, 0x01, 0x00]);

    // Wrap bytes into Bytecode (legacy format)
    let bytecode = Bytecode::new_legacy(code);

    // Initialize the interpreter
    let mut interpreter = Interpreter::new(
        revm::interpreter::SharedMemory::new(), // memory buffer
        revm::interpreter::ExtBytecode::new(bytecode),
        revm::interpreter::InputsImpl {
            target_address: Address::ZERO,
            caller_address: Address::ZERO,
            input: Bytes::new(),
            call_value: U256::ZERO,
        },
        false,          // is_static
        false,          // is_eof_init
        revm::primitives::hardfork::SpecId::LATEST,
        1_000_000,      // gas limit
    );

    // Prepare instruction table
    let instr_table = instruction_table::&lt;revm::interpreter::EthInterpreter, _&gt;();

    // Run interpreter until halt
    let result = interpreter.run_plain(&amp;instr_table, &amp;mut revm::interpreter::DummyHost);

    // Output gas used and the top stack value (5 expected)
    println!("Gas left: {}", result.gas.remaining());
    println!("Execution result success: {}", result.is_ok());
    // Note: output bytes are empty here since no RETURN opcode
}</code></pre></pre>
<p><strong>What happens here?</strong></p>
<ul>
<li>We provide some bytecode pushing <code>2</code> and <code>3</code>, adds them, and stops.</li>
<li>Create the Interpreter instance.</li>
<li>Run it with the instruction table (which has all opcode implementations).</li>
<li>Finally print gas left and execution success.</li>
</ul>
<hr />
<h2 id="what-happens-inside-the-interpreter-step-by-step"><a class="header" href="#what-happens-inside-the-interpreter-step-by-step">What Happens Inside the Interpreter? Step-by-Step</a></h2>
<p>Let's visualize what happens during execution of this bytecode:</p>
<pre class="mermaid">sequenceDiagram
    participant Int as Interpreter
    participant Host as Host Interface (dummy here)
    participant Stack as Internal Stack
    participant Mem as Memory
    participant Gas as Gas Tracker

    Int-&gt;&gt;Int: Fetch opcode at PC=0 (PUSH1)
    Int-&gt;&gt;Stack: Push 2 onto stack
    Int-&gt;&gt;Gas: Deduct gas for PUSH1
    Int-&gt;&gt;Int: PC += 2

    Int-&gt;&gt;Int: Fetch opcode at PC=2 (PUSH1)
    Int-&gt;&gt;Stack: Push 3 onto stack
    Int-&gt;&gt;Gas: Deduct gas
    Int-&gt;&gt;Int: PC += 2

    Int-&gt;&gt;Int: Fetch opcode at PC=4 (ADD)
    Int-&gt;&gt;Stack: Pop 2 and 3
    Int-&gt;&gt;Stack: Push 5
    Int-&gt;&gt;Gas: Deduct gas for ADD
    Int-&gt;&gt;Int: PC += 1

    Int-&gt;&gt;Int: Fetch opcode at PC=5 (STOP)
    Int-&gt;&gt;Int: Halt execution

    Int--&gt;&gt;Host: No host calls needed
    Int--&gt;&gt;User: Return final gas, output, status
</pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li>The Interpreter reads each opcode sequentially.</li>
<li>Executes the corresponding instruction function.</li>
<li>Manages stack and gas accordingly.</li>
<li>Stops when it reads a <code>STOP</code> (or other halting instruction).</li>
</ul>
<hr />
<h2 id="diving-deeper-how-does-the-interpreter-implement-each-opcode"><a class="header" href="#diving-deeper-how-does-the-interpreter-implement-each-opcode">Diving Deeper: How Does the Interpreter Implement Each Opcode?</a></h2>
<p>The <code>revm</code> interpreter uses an <strong>instruction table</strong> — an array indexed by opcode numbers — where each entry points to the function handling that opcode.</p>
<p>Here is a small simplified example from <code>crates/interpreter/src/instructions.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Instruction&lt;W, H&gt; = for&lt;'a&gt; fn(&amp;'a mut Interpreter&lt;W&gt;, &amp;'a mut H);

// Instruction function for ADD opcode (0x01)
fn add&lt;W: InterpreterTypes, H: Host + ?Sized&gt;(
    interp: &amp;mut Interpreter&lt;W&gt;,
    _host: &amp;mut H,
) {
    // Pop two values from stack
    let a = interp.stack.pop().expect("stack underflow");
    let b = interp.stack.pop().expect("stack underflow");

    // Add and push result
    interp.stack.push(a + b);

    // Deduct gas (simplified)
    interp.control.gas_mut().record_cost(3);
}

// The instruction table filling example
let mut table = [control::unknown as Instruction&lt;W, H&gt;; 256];
table[0x01] = add;
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Each instruction function receives a mutable interpreter and host.</li>
<li>Executes the opcode logic (stack ops, memory, host calls).</li>
<li>Updates gas.</li>
<li>Updates program counter implicitly by the interpreter’s run loop.</li>
</ul>
<p>This approach makes the interpreter <strong>fast and modular</strong>.</p>
<hr />
<h2 id="how-does-the-interpreter-handle-control-flow"><a class="header" href="#how-does-the-interpreter-handle-control-flow">How Does the Interpreter Handle Control Flow?</a></h2>
<p>Some instructions alter the program counter directly:</p>
<ul>
<li><code>JUMP</code> sets PC to a new location learned from stack.</li>
<li><code>JUMPI</code> conditionally jumps.</li>
<li><code>CALL</code> and <code>CREATE</code> trigger sub-interpreters for nested contract calls.</li>
</ul>
<p>Here is a very tiny look at <code>JUMP</code> instruction handler simplified:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn jump&lt;W: InterpreterTypes, H: Host + ?Sized&gt;(interp: &amp;mut Interpreter&lt;W&gt;, _host: &amp;mut H) {
    let dest = interp.stack.pop().expect("stack underflow");
    let dest_usize = dest.as_usize();

    // Check if jumpdest is valid (jump table)
    if !interp.bytecode.legacy_jump_table().map_or(false, |table| table[dest_usize]) {
        interp.control.set_next_action(
            InterpreterAction::Return {
                result: InstructionResult::InvalidJump,
                output: Bytes::new(),
                gas: interp.control.gas().clone(),
            },
            InstructionResult::InvalidJump,
        );
        return;
    }

    // Move PC to jump destination
    interp.bytecode.set_pc(dest_usize);
}
<span class="boring">}</span></code></pre></pre>
<p>This shows how the interpreter validates jump destinations and moves the PC accordingly.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What the Interpreter is:</strong><br />
It's the virtual CPU of the EVM that reads, decodes, and executes smart contract bytecode.</p>
</li>
<li>
<p><strong>Key responsibilities:</strong><br />
Managing the stack, memory, gas, program counter, executing instructions step by step.</p>
</li>
<li>
<p><strong>Core components:</strong><br />
Bytecode with program counter, stack, memory, gas management, host interface, instruction lookup table.</p>
</li>
<li>
<p><strong>How to use it:</strong><br />
Create an interpreter instance with bytecode, then run it using the instruction table.</p>
</li>
<li>
<p><strong>Internal workings:</strong><br />
The interpreter fetches opcodes sequentially, executes their handlers, manages flow and gas, and halts on <code>STOP</code> or error.</p>
</li>
<li>
<p><strong>Control flow handled via jumps and calls with validation.</strong></p>
</li>
</ul>
<p>The Interpreter is the beating heart of <code>revm</code> that brings smart contract code execution to reality!</p>
<hr />
<p>Next up, we will explore how the EVM uses this Interpreter when managing <strong>frames and call handling</strong> — how contracts call each other and manage execution contexts. Let’s continue with <a href="08_frame___call_handling_.html">Chapter 8: Frame &amp; Call Handling</a>.</p>
<hr />
<p>Thank you for following along! You’re now equipped with a solid understanding of how the EVM executes smart contracts step-by-step using the Interpreter. Keep exploring!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Revm/06_precompiles_.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Revm/08_frame___call_handling_.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Revm/06_precompiles_.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Revm/08_frame___call_handling_.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
