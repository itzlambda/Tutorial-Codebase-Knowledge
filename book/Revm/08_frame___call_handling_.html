<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Frame &amp; Call Handling - Tutorial Codebase Knowledge</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tutorial Codebase Knowledge</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-8-frame--call-handling"><a class="header" href="#chapter-8-frame--call-handling">Chapter 8: Frame &amp; Call Handling</a></h1>
<p>Welcome back! In the previous chapter, <a href="07_interpreter_.html">Interpreter</a>, we learned how the EVM reads and executes smart contract bytecode step-by-step. Now, we're going one level <em>above</em> the interpreter to understand <strong>how the EVM manages multiple nested calls and contract creations during execution</strong>.</p>
<p>This chapter covers the important concept of <strong>Frames &amp; Call Handling</strong> — the way <code>revm</code> organizes execution contexts, manages nested calls, tracks local states, and returns results smoothly.</p>
<hr />
<h2 id="why-do-we-need-frames--call-handling"><a class="header" href="#why-do-we-need-frames--call-handling">Why Do We Need Frames &amp; Call Handling?</a></h2>
<p>Imagine you're watching a TV series where characters frequently call each other on the phone. Each conversation is a <strong>call</strong>. Some calls may involve another call inside them (like a conference call), and each call has its own context: who's talking, what was said before, what will happen next.</p>
<p>In the EVM:</p>
<ul>
<li>Smart contracts <em>call</em> other contracts.</li>
<li>Contracts <em>create</em> new contracts.</li>
<li>Calls can be nested many layers deep.</li>
<li>Each call has its own execution environment — stack, memory, gas limits.</li>
<li>We need to keep track of these <strong>execution contexts</strong> so that when a nested call finishes, its result comes back correctly to the original caller.</li>
<li>We must manage gas usage, state changes, and errors per call.</li>
<li>Sometimes calls revert, and we need to revert state changes only in that sub-call.</li>
</ul>
<p>This is the job of <strong>Frames &amp; Call Handling</strong>. They act like <strong>"context managers"</strong> that keep track of:</p>
<ul>
<li>The current executing contract (frame).</li>
<li>Parent and child execution frames (call stack).</li>
<li>Memory and gas per call.</li>
<li>Checkpoints for safe state reverting.</li>
<li>Propagating results back up after calls.</li>
</ul>
<hr />
<h2 id="a-central-use-case-a-contract-calls-another-contract"><a class="header" href="#a-central-use-case-a-contract-calls-another-contract">A Central Use Case: A Contract Calls Another Contract</a></h2>
<p>Suppose contract A calls contract B:</p>
<ul>
<li>Contract A starts executing (Frame A).</li>
<li>It runs an instruction <code>CALL</code> to contract B.</li>
<li>Frame B is created, executing contract B’s code with its own gas and memory.</li>
<li>Contract B finishes and returns some data.</li>
<li>Frame B ends, popping from the call stack and letting Frame A resume.</li>
<li>Contract A uses the result and continues execution.</li>
</ul>
<p>During this process, we want to:</p>
<ul>
<li>Manage separate <code>Gas</code> for contract B’s execution.</li>
<li>Track state changes in Frame B, but only commit them if B succeeds. If B reverts, revert those changes without affecting A.</li>
<li>Pass the output data of Frame B back to Frame A.</li>
</ul>
<p>How does <code>revm</code> handle this? Through a combination of <strong>frames</strong>, <strong>call stacks</strong>, and <strong>state checkpointing</strong>.</p>
<hr />
<h2 id="key-concepts-of-frame--call-handling"><a class="header" href="#key-concepts-of-frame--call-handling">Key Concepts of Frame &amp; Call Handling</a></h2>
<p>Let's break this complex idea into simple pieces:</p>
<h3 id="1-frame"><a class="header" href="#1-frame">1. <strong>Frame</strong></a></h3>
<ul>
<li>A <strong>frame</strong> is an execution context for a single call or contract creation.</li>
<li>It includes:
<ul>
<li>The contract code being run.</li>
<li>Memory and stack for this execution.</li>
<li>Gas allocated for this call.</li>
<li>State checkpoint for rollback.</li>
<li>Information about call depth.</li>
<li>Input data and values transferred.</li>
</ul>
</li>
</ul>
<h3 id="2-call-stack"><a class="header" href="#2-call-stack">2. <strong>Call Stack</strong></a></h3>
<ul>
<li>The call stack tracks <strong>all active frames</strong>, like a stack of trays in a kitchen.</li>
<li>When a new call or creation happens, a new frame is <em>pushed</em> onto the stack.</li>
<li>When the call finishes, that frame is <em>popped</em> off.</li>
<li>The stack limit prevents too deep nesting (usually max 1024 calls).</li>
</ul>
<h3 id="3-checkpointing"><a class="header" href="#3-checkpointing">3. <strong>Checkpointing</strong></a></h3>
<ul>
<li>Before starting a new call frame, revm creates a <strong>checkpoint</strong> of the blockchain state using "journaling".</li>
<li>If the call succeeds, the checkpoint is <strong>committed</strong>, making changes permanent.</li>
<li>If the call reverts, the checkpoint is <strong>reverted</strong>, undoing all changes during that call.</li>
</ul>
<h3 id="4-call-inputs-and-outputs"><a class="header" href="#4-call-inputs-and-outputs">4. <strong>Call Inputs and Outputs</strong></a></h3>
<ul>
<li>
<p><strong>Inputs</strong> include:</p>
<ul>
<li>Target address</li>
<li>Caller address</li>
<li>Input calldata</li>
<li>Gas allocated for this call</li>
<li>Transfer value (ETH)</li>
<li>Call scheme (CALL, DELEGATECALL, CREATE, etc.)</li>
</ul>
</li>
<li>
<p><strong>Outputs</strong> include:</p>
<ul>
<li>Result (success, revert, or error)</li>
<li>Gas remaining</li>
<li>Output data (return or revert data)</li>
<li>Any created address (for creations)</li>
</ul>
</li>
</ul>
<h3 id="5-frame-data-and-frame-result"><a class="header" href="#5-frame-data-and-frame-result">5. <strong>Frame Data and Frame Result</strong></a></h3>
<ul>
<li>Frames carry internal data: like return memory range (for calls) or created address (for creations).</li>
<li>When execution ends, frames produce a <strong>frame result</strong> which wraps the outputs in a uniform way.</li>
</ul>
<hr />
<h2 id="how-to-use-frames--call-handling-in-revm"><a class="header" href="#how-to-use-frames--call-handling-in-revm">How to Use Frames &amp; Call Handling in <code>revm</code></a></h2>
<p>Let's look at a beginner-friendly example simulating a simple call frame creation and running it.</p>
<h3 id="step-1-define-inputs-for-a-call"><a class="header" href="#step-1-define-inputs-for-a-call">Step 1: Define Inputs for a Call</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::interpreter::{CallInputs, CallScheme, CallValue};
use primitives::{Address, Bytes, U256};

let target_address = "0x0000000000000000000000000000000000000001".parse().unwrap();
let caller_address = "0x0000000000000000000000000000000000000002".parse().unwrap();

let call_inputs = CallInputs {
    target_address,
    caller: caller_address,
    input: Bytes::from_static(b"hello"),  // input data to the call
    value: CallValue::Transfer(U256::zero()), // no ETH transferred
    gas_limit: 1_000_000,
    scheme: CallScheme::Call,
    is_static: false,
    ..Default::default()
};
<span class="boring">}</span></code></pre></pre>
<p><em>Here we prepare all the parameters needed to make a call frame.</em></p>
<h3 id="step-2-create-a-call-frame"><a class="header" href="#step-2-create-a-call-frame">Step 2: Create a Call Frame</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use revm::handler::EthFrame;
use revm::interpreter::SharedMemory;

let mut evm = /* create and initialize your EVM runtime with context and precompiles */;
let depth = 0;
let memory = SharedMemory::new();

let result = EthFrame::make_call_frame(&amp;mut evm, depth, memory, Box::new(call_inputs));

match result {
    Ok(revm::handler::ItemOrResult::Item(frame)) =&gt; {
        println!("Successfully created call frame at depth {}", depth);
        // You can now run the frame interpreter (see next step)
    }
    Ok(revm::handler::ItemOrResult::Result(res)) =&gt; {
        println!("Call failed immediately with result: {:?}", res.instruction_result());
    }
    Err(e) =&gt; {
        println!("Failed to create call frame: {:?}", e);
    }
}
<span class="boring">}</span></code></pre></pre>
<p><em>This attempts to create a call frame with the given inputs. If call stack depth exceeds limit or funds are insufficient, it returns error.</em></p>
<h3 id="step-3-running-the-frame"><a class="header" href="#step-3-running-the-frame">Step 3: Running the Frame</a></h3>
<p>You would then run the <code>Interpreter</code> associated with this frame, which runs contract B’s code step by step as explained in <a href="07_interpreter_.html">Chapter 7: Interpreter</a>.</p>
<p>When the frame execution is complete, you get a <code>FrameResult</code>, which you can then process to:</p>
<ul>
<li>Commit or revert the state checkpoint.</li>
<li>Return gas and output to the caller.</li>
<li>Pop the frame from the call stack.</li>
</ul>
<hr />
<h2 id="what-happens-internally-step-by-step-call-frame-flow"><a class="header" href="#what-happens-internally-step-by-step-call-frame-flow">What Happens Internally? Step-by-Step Call Frame Flow</a></h2>
<pre class="mermaid">sequenceDiagram
    participant Caller as Caller Frame (e.g., contract A)
    participant Handler as Frame Handler
    participant Frame as New Call Frame (e.g., contract B)
    participant Journal as Journal &amp; State Checkpoint
    participant Interpreter as Bytecode Interpreter

    Caller-&gt;&gt;Handler: Request to start new call frame with inputs
    Handler-&gt;&gt;Journal: Create state checkpoint for call frame
    Handler-&gt;&gt;Frame: Initialize frame with interpreter, inputs, depth, checkpoint
    Frame-&gt;&gt;Interpreter: Run contract bytecode with gas &amp; inputs
    Interpreter--&gt;&gt;Frame: Return execution result (success/error)
    alt Execution success
        Handler-&gt;&gt;Journal: Commit checkpoint to state
    else Execution failed or reverted
        Handler-&gt;&gt;Journal: Revert checkpoint (undo changes)
    end
    Frame--&gt;&gt;Handler: Return FrameResult (gas, output, status)
    Handler-&gt;&gt;Caller: Pass call output and gas back
</pre>
<h3 id="explanation"><a class="header" href="#explanation">Explanation:</a></h3>
<ul>
<li>Each new call creates a <strong>frame</strong> with isolated execution environment.</li>
<li>A <strong>checkpoint</strong> snapshot of state is used to manage changes safely.</li>
<li>The <code>Interpreter</code> runs the code inside the frame.</li>
<li>On success, changes are committed; on revert, all changes are undone.</li>
<li>The outcome (success/fail, gas, output data) propagates back up through the call stack.</li>
</ul>
<hr />
<h2 id="peeking-under-the-hood-how-frame-handling-is-implemented"><a class="header" href="#peeking-under-the-hood-how-frame-handling-is-implemented">Peeking Under the Hood: How Frame Handling Is Implemented</a></h2>
<h3 id="the-frame-trait--ethframe-struct"><a class="header" href="#the-frame-trait--ethframe-struct">The Frame Trait &amp; <code>EthFrame</code> Struct</a></h3>
<p>In <code>crates/handler/src/frame.rs</code>, the core <code>Frame</code> trait defines operations for frames like initializing, running, and returning results:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Frame: Sized {
    type Evm;
    type FrameInit;
    type FrameResult;
    type Error;

    fn init_first(evm: &amp;mut Self::Evm, frame_input: Self::FrameInit)
        -&gt; Result&lt;FrameOrResult&lt;Self&gt;, Self::Error&gt;;

    fn run(&amp;mut self, evm: &amp;mut Self::Evm) -&gt; Result&lt;FrameInitOrResult&lt;Self&gt;, Self::Error&gt;;

    fn return_result(&amp;mut self, evm: &amp;mut Self::Evm, result: Self::FrameResult)
        -&gt; Result&lt;(), Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>init_first</code>: creates the first frame.</li>
<li><code>run</code>: runs the frame (runs the interpreter until stop).</li>
<li><code>return_result</code>: handles returning the frame's output to the caller.</li>
</ul>
<p>The concrete implementation for Ethereum is in <code>EthFrame</code>, which holds:</p>
<ul>
<li>Frame data (<code>CallFrame</code>, <code>CreateFrame</code>, etc.)</li>
<li>Input parameters</li>
<li>The interpreter instance for executing code</li>
<li>Checkpoint from the journal for state rollback</li>
</ul>
<h3 id="using-checkpoints"><a class="header" href="#using-checkpoints">Using Checkpoints</a></h3>
<p>The journal (see <a href="01_context___environment_.html">Chapter 1: Context &amp; Environment</a>) supports <strong>checkpoints</strong>:</p>
<ul>
<li>When a frame starts, a checkpoint is saved.</li>
<li>If the frame finishes successfully, checkpoint commits.</li>
<li>Otherwise, checkpoint reverts changes.</li>
</ul>
<p>Simple example of checkpoint usage:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let checkpoint = context.journal().checkpoint();

// Execute something
let result = interpreter.run();

if result.is_success() {
    context.journal().checkpoint_commit();
} else {
    context.journal().checkpoint_revert(checkpoint);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="call-depth--limits"><a class="header" href="#call-depth--limits">Call Depth &amp; Limits</a></h3>
<p>Frames track <code>depth</code>, which is checked to ensure call stacks do not grow beyond allowed limits (<code>CALL_STACK_LIMIT</code>). Exceeding the limit immediately fails the call.</p>
<h3 id="returning-results-to-caller"><a class="header" href="#returning-results-to-caller">Returning Results to Caller</a></h3>
<p>Return data and gas are carefully passed back to the caller frame so it can continue execution, pushing return values to the stack and refunding unused gas.</p>
<hr />
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>In this chapter, you learned:</p>
<ul>
<li>
<p><strong>What are frames?</strong><br />
Execution contexts for single calls or contract creations, encapsulating interpreter state, gas, memory, and checkpoints.</p>
</li>
<li>
<p><strong>Why are frames important?</strong><br />
They let <code>revm</code> support nested contract calls safely with proper state management and gas tracking.</p>
</li>
<li>
<p><strong>How the call stack works:</strong><br />
Frames are pushed on calls and popped on returns. Depth limits prevent abuse.</p>
</li>
<li>
<p><strong>Checkpointing state:</strong><br />
Frames create snapshots of the state before execution, allowing revert on call failure and commit on success.</p>
</li>
<li>
<p><strong>How inputs and outputs flow:</strong><br />
Calls supply gas, input data, value, and get back gas remaining and return data.</p>
</li>
<li>
<p><strong>Basic API usage to create and run frames:</strong></p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>EthFrame::make_call_frame(...) -&gt; Result&lt;ItemOrResult&lt;EthFrame&gt;, Error&gt;
// run interpreter and process result
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Internal flow:</strong><br />
The handler calls frame initialization, then runs the interpreter inside frames, manages state with checkpoints, and correctly returns results.</li>
</ul>
<p>This layered approach cleanly separates execution of nested calls, making it easy to understand, manage, and debug complex contract interactions!</p>
<hr />
<p>Next, we'll learn how the <strong>Handler &amp; Execution Loop</strong> uses frames to manage the entire EVM call stack and keep your contracts running smoothly. Head over to <a href="09_handler___execution_loop_.html">Chapter 9: Handler &amp; Execution Loop</a> to continue the journey!</p>
<hr />
<p>Thank you for following along! Frames and call handling are the backbone of smart contract execution, enabling nested calls and safe context switching inside the EVM. You're doing fantastic—keep going!</p>
<hr />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../Revm/07_interpreter_.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../Revm/09_handler___execution_loop_.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../Revm/07_interpreter_.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../Revm/09_handler___execution_loop_.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
